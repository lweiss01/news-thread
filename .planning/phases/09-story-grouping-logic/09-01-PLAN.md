---
id: "09-01"
name: "Story Update Worker"
wave: "1"
depends_on: []
files_snapshot:
  - "app/src/main/java/com/newsthread/app/worker/StoryUpdateWorker.kt"
  - "app/src/main/java/com/newsthread/app/domain/usecase/UpdateTrackedStoriesUseCase.kt"
  - "app/src/main/java/com/newsthread/app/domain/repository/TrackingRepository.kt"
  - "app/src/main/java/com/newsthread/app/data/repository/TrackingRepositoryImpl.kt"
  - "app/src/main/java/com/newsthread/app/data/local/dao/StoryDao.kt"
  - "app/src/main/java/com/newsthread/app/data/local/dao/CachedArticleDao.kt"
  - "app/src/main/java/com/newsthread/app/di/WorkerModule.kt"
---

<objective>
Create a background worker that automatically matches new feed articles to tracked stories using semantic similarity. Articles matching with ≥0.70 similarity are auto-added; articles with 0.50-0.69 are flagged as "possibly related" for user review.
</objective>

<context>
Phase 8 established the tracking data layer (StoryEntity, StoryDao, TrackingRepository). This phase builds on that foundation by adding automatic story updates. The worker follows the ArticleAnalysisWorker pattern (HiltWorker with repository injection) and reuses SimilarityMatcher for cosine similarity.

Per 09-CONTEXT.md:
- 2-hour periodic sync interval
- Tiered matching: ≥0.70 auto-add, ≥0.50 possibly related
- Novelty detection to avoid "5 more outlets wrote the same thing" noise
- Source diversity detection for cross-bias notifications
</context>

<tasks>
  <task id="dao_updates" name="Extend DAO Methods">
    <description>
      Add methods to CachedArticleDao for fetching recent feed articles with embeddings.
      Add methods to StoryDao for efficient story-article matching queries.
    </description>
    <action type="modify" path="app/src/main/java/com/newsthread/app/data/local/dao/CachedArticleDao.kt">
      <diff>
        <![CDATA[
// Add method to get recent articles with embeddings (for matching)
@Query("""
    SELECT * FROM cached_articles 
    WHERE embedding IS NOT NULL 
    AND storyId IS NULL
    AND cachedAt > :since
    ORDER BY cachedAt DESC
""")
suspend fun getRecentUnassignedArticlesWithEmbeddings(since: Long): List<CachedArticleEntity>

// Add method to assign article to story
@Query("UPDATE cached_articles SET storyId = :storyId WHERE url = :articleUrl")
suspend fun assignArticleToStory(articleUrl: String, storyId: String)
        ]]>
      </diff>
    </action>
    <action type="modify" path="app/src/main/java/com/newsthread/app/data/local/dao/StoryDao.kt">
      <diff>
        <![CDATA[
// Add method to get story embeddings (centroid calculation)
@Query("""
    SELECT ca.embedding FROM cached_articles ca
    WHERE ca.storyId = :storyId AND ca.embedding IS NOT NULL
""")
suspend fun getStoryArticleEmbeddings(storyId: String): List<ByteArray>

// Add method to update story timestamp
@Query("UPDATE stories SET updatedAt = :timestamp WHERE id = :storyId")
suspend fun updateStoryTimestamp(storyId: String, timestamp: Long)
        ]]>
      </diff>
    </action>
  </task>

  <task id="tracking_repo" name="Extend TrackingRepository">
    <description>
      Add methods for story matching workflow to TrackingRepository interface and implementation.
    </description>
    <action type="modify" path="app/src/main/java/com/newsthread/app/domain/repository/TrackingRepository.kt">
      <diff>
        <![CDATA[
// Add interface methods for story update worker
suspend fun getStoryArticleEmbeddings(storyId: String): List<FloatArray>
suspend fun addArticleToStory(articleUrl: String, storyId: String)
suspend fun markStoryUpdated(storyId: String)
        ]]>
      </diff>
    </action>
    <action type="modify" path="app/src/main/java/com/newsthread/app/data/repository/TrackingRepositoryImpl.kt">
      <diff>
        <![CDATA[
// Implement story update methods
override suspend fun getStoryArticleEmbeddings(storyId: String): List<FloatArray> {
    return storyDao.getStoryArticleEmbeddings(storyId)
        .mapNotNull { bytes -> EmbeddingSerializer.fromBytes(bytes) }
}

override suspend fun addArticleToStory(articleUrl: String, storyId: String) {
    cachedArticleDao.assignArticleToStory(articleUrl, storyId)
    storyDao.updateStoryTimestamp(storyId, System.currentTimeMillis())
}

override suspend fun markStoryUpdated(storyId: String) {
    storyDao.updateStoryTimestamp(storyId, System.currentTimeMillis())
}
        ]]>
      </diff>
    </action>
  </task>

  <task id="usecase" name="Create UpdateTrackedStoriesUseCase">
    <description>
      Encapsulate the story matching logic as a domain use case.
      Implements tiered matching, novelty detection, and source diversity checks.
    </description>
    <action type="create" path="app/src/main/java/com/newsthread/app/domain/usecase/UpdateTrackedStoriesUseCase.kt">
      <diff>
        <![CDATA[
package com.newsthread.app.domain.usecase

import com.newsthread.app.data.local.dao.CachedArticleDao
import com.newsthread.app.data.local.entity.CachedArticleEntity
import com.newsthread.app.domain.repository.TrackingRepository
import com.newsthread.app.domain.similarity.MatchStrength
import com.newsthread.app.domain.similarity.SimilarityMatcher
import javax.inject.Inject
import javax.inject.Singleton
import kotlin.time.Duration.Companion.hours

/**
 * Match result with classification for UI display.
 */
data class StoryMatchResult(
    val articleUrl: String,
    val storyId: String,
    val similarity: Float,
    val strength: MatchStrength,
    val isNovel: Boolean,
    val hasNewPerspective: Boolean
)

@Singleton
class UpdateTrackedStoriesUseCase @Inject constructor(
    private val trackingRepository: TrackingRepository,
    private val cachedArticleDao: CachedArticleDao,
    private val similarityMatcher: SimilarityMatcher
) {
    companion object {
        private const val NOVELTY_THRESHOLD = 0.85f
        private val MATCHING_WINDOW = 24.hours.inWholeMilliseconds
    }

    suspend operator fun invoke(): List<StoryMatchResult> {
        val stories = trackingRepository.getTrackedStories().first()
        if (stories.isEmpty()) return emptyList()

        val since = System.currentTimeMillis() - MATCHING_WINDOW
        val candidateArticles = cachedArticleDao.getRecentUnassignedArticlesWithEmbeddings(since)
        if (candidateArticles.isEmpty()) return emptyList()

        val results = mutableListOf<StoryMatchResult>()

        stories.forEach { storyWithArticles ->
            val storyId = storyWithArticles.story.id
            val storyEmbeddings = trackingRepository.getStoryArticleEmbeddings(storyId)
            if (storyEmbeddings.isEmpty()) return@forEach

            val storyCentroid = computeCentroid(storyEmbeddings)
            val existingBiasCategories = storyWithArticles.articles
                .mapNotNull { it.biasScore?.toInt() }
                .toSet()

            candidateArticles.forEach { article ->
                val articleEmbedding = article.getEmbeddingAsFloatArray() ?: return@forEach
                val similarity = similarityMatcher.cosineSimilarity(articleEmbedding, storyCentroid)
                val strength = similarityMatcher.matchStrength(similarity)

                if (strength != MatchStrength.NONE) {
                    val isNovel = isNovelContent(articleEmbedding, storyEmbeddings)
                    val hasNewPerspective = hasNewPerspective(article, existingBiasCategories)

                    // Auto-add strong matches
                    if (strength == MatchStrength.STRONG) {
                        trackingRepository.addArticleToStory(article.url, storyId)
                    }

                    results.add(StoryMatchResult(
                        articleUrl = article.url,
                        storyId = storyId,
                        similarity = similarity,
                        strength = strength,
                        isNovel = isNovel,
                        hasNewPerspective = hasNewPerspective
                    ))
                }
            }
        }

        return results
    }

    private fun computeCentroid(embeddings: List<FloatArray>): FloatArray {
        if (embeddings.isEmpty()) return FloatArray(0)
        val dim = embeddings.first().size
        val centroid = FloatArray(dim)
        embeddings.forEach { emb ->
            for (i in centroid.indices) {
                centroid[i] += emb[i]
            }
        }
        for (i in centroid.indices) {
            centroid[i] /= embeddings.size
        }
        return centroid
    }

    private fun isNovelContent(newEmbedding: FloatArray, existingEmbeddings: List<FloatArray>): Boolean {
        val centroid = computeCentroid(existingEmbeddings)
        val similarityToCentroid = similarityMatcher.cosineSimilarity(newEmbedding, centroid)
        return similarityToCentroid < NOVELTY_THRESHOLD
    }

    private fun hasNewPerspective(article: CachedArticleEntity, existingBiasCategories: Set<Int>): Boolean {
        val newBiasCategory = article.biasScore?.toInt() ?: return false
        return newBiasCategory !in existingBiasCategories
    }
}
        ]]>
      </diff>
    </action>
  </task>

  <task id="worker" name="Create StoryUpdateWorker">
    <description>
      Create the WorkManager worker following ArticleAnalysisWorker pattern.
      Runs every 2 hours per 09-CONTEXT.md decision.
    </description>
    <action type="create" path="app/src/main/java/com/newsthread/app/worker/StoryUpdateWorker.kt">
      <diff>
        <![CDATA[
package com.newsthread.app.worker

import android.content.Context
import android.util.Log
import androidx.hilt.work.HiltWorker
import androidx.work.CoroutineWorker
import androidx.work.WorkerParameters
import com.newsthread.app.domain.usecase.UpdateTrackedStoriesUseCase
import com.newsthread.app.domain.similarity.MatchStrength
import dagger.assisted.Assisted
import dagger.assisted.AssistedInject

@HiltWorker
class StoryUpdateWorker @AssistedInject constructor(
    @Assisted appContext: Context,
    @Assisted workerParams: WorkerParameters,
    private val updateTrackedStoriesUseCase: UpdateTrackedStoriesUseCase
) : CoroutineWorker(appContext, workerParams) {

    override suspend fun doWork(): Result {
        Log.d(TAG, "Starting story update sync")

        return try {
            val results = updateTrackedStoriesUseCase()
            
            val strongMatches = results.count { it.strength == MatchStrength.STRONG }
            val weakMatches = results.count { it.strength == MatchStrength.WEAK }
            val novelMatches = results.count { it.isNovel }
            val perspectiveMatches = results.count { it.hasNewPerspective }

            Log.d(TAG, """
                Story update complete:
                - Strong matches (auto-added): $strongMatches
                - Weak matches (for review): $weakMatches
                - Novel content: $novelMatches
                - New perspectives: $perspectiveMatches
            """.trimIndent())

            Result.success()
        } catch (e: Exception) {
            Log.e(TAG, "Story update failed", e)
            Result.retry()
        }
    }

    companion object {
        const val TAG = "StoryUpdateWorker"
        const val WORK_NAME = "story_update_sync"
    }
}
        ]]>
      </diff>
    </action>
  </task>

  <task id="scheduling" name="Schedule Worker in Application">
    <description>
      Add periodic work scheduling in NewsThreadApp or a dedicated WorkerScheduler.
      Uses 2-hour interval with battery optimization constraints.
    </description>
    <action type="modify" path="app/src/main/java/com/newsthread/app/NewsThreadApp.kt">
      <diff>
        <![CDATA[
import androidx.work.ExistingPeriodicWorkPolicy
import androidx.work.PeriodicWorkRequestBuilder
import androidx.work.WorkManager
import androidx.work.Constraints
import com.newsthread.app.worker.StoryUpdateWorker
import java.util.concurrent.TimeUnit

// In onCreate(), add worker scheduling:
private fun scheduleStoryUpdates() {
    val constraints = Constraints.Builder()
        .setRequiresBatteryNotLow(true)
        .build()

    val storyUpdateRequest = PeriodicWorkRequestBuilder<StoryUpdateWorker>(
        repeatInterval = 2,
        repeatIntervalTimeUnit = TimeUnit.HOURS
    )
        .setConstraints(constraints)
        .build()

    WorkManager.getInstance(this).enqueueUniquePeriodicWork(
        StoryUpdateWorker.WORK_NAME,
        ExistingPeriodicWorkPolicy.KEEP,
        storyUpdateRequest
    )
}
        ]]>
      </diff>
    </action>
  </task>
</tasks>

<verification>
  <must_have>
    - [ ] `StoryUpdateWorker` is a `@HiltWorker` with injected `UpdateTrackedStoriesUseCase`
    - [ ] `UpdateTrackedStoriesUseCase` computes cosine similarity against story centroid
    - [ ] Strong matches (≥0.70) are auto-added to story via `addArticleToStory`
    - [ ] Weak matches (0.50-0.69) are returned as results for UI display
    - [ ] Novelty detection uses centroid comparison with 0.85 threshold
    - [ ] Source diversity checks existing bias categories against new article
    - [ ] Worker is scheduled with 2-hour interval and battery-low constraint
    - [ ] App builds successfully without errors
  </must_have>

  <unit_tests>
    Run existing tests to prevent regressions:
    ```bash
    ./gradlew test --tests "com.newsthread.app.domain.similarity.SimilarityMatcherTest"
    ./gradlew test --tests "com.newsthread.app.data.repository.TrackingRepositoryTest"
    ```
    
    Add new test for UpdateTrackedStoriesUseCase:
    ```bash
    ./gradlew test --tests "com.newsthread.app.domain.usecase.UpdateTrackedStoriesUseCaseTest"
    ```
  </unit_tests>

  <manual_test>
    1. Build and install the app
    2. Track a story (long-press article in feed)
    3. Check Logcat for "StoryUpdateWorker" tag
    4. Force-run worker via ADB:
       ```
       adb shell cmd jobscheduler run -f com.newsthread.app 1
       ```
    5. Verify "Story update complete" log with match counts
    6. Check that new matching articles appear under tracked story
  </manual_test>
</verification>
