---
phase: 02-text-extraction
plan: 03
type: execute
wave: 2
depends_on: ["02-01", "02-02"]
files_modified:
  - app/src/main/java/com/newsthread/app/data/local/dao/CachedArticleDao.kt
  - app/src/main/java/com/newsthread/app/data/repository/UserPreferencesRepository.kt
  - app/src/main/java/com/newsthread/app/data/repository/TextExtractionRepository.kt
autonomous: true

must_haves:
  truths:
    - "User preference for fetch behavior is persisted in DataStore"
    - "Text extraction respects user's WiFi-only/always/never preference"
    - "Extracted text is saved to Room via CachedArticleDao.updateFullText()"
    - "Extraction handles paywall, network errors, and parsing failures with fallback"
  artifacts:
    - path: "app/src/main/java/com/newsthread/app/data/local/dao/CachedArticleDao.kt"
      provides: "Query for articles needing extraction"
      contains: "getArticlesNeedingExtraction"
    - path: "app/src/main/java/com/newsthread/app/data/repository/UserPreferencesRepository.kt"
      provides: "DataStore persistence for fetch preference"
      contains: "articleFetchPreference"
    - path: "app/src/main/java/com/newsthread/app/data/repository/TextExtractionRepository.kt"
      provides: "Orchestrates HTML fetch, Readability extraction, Room save"
      contains: "suspend fun extractAndSave"
  key_links:
    - from: "TextExtractionRepository"
      to: "ArticleHtmlFetcher"
      via: "Hilt injection"
      pattern: "articleHtmlFetcher\\.fetch"
    - from: "TextExtractionRepository"
      to: "Readability4JExtended"
      via: "parse() call"
      pattern: "Readability4JExtended.*\\.parse"
    - from: "TextExtractionRepository"
      to: "CachedArticleDao.updateFullText"
      via: "Save extracted text"
      pattern: "cachedArticleDao\\.updateFullText"
    - from: "UserPreferencesRepository"
      to: "DataStore"
      via: "Preferences storage"
      pattern: "dataStore\\.data"
---

<objective>
Create the core extraction repository that orchestrates the full pipeline

Purpose: TextExtractionRepository is the central component that ties together HTML fetching, Readability extraction, paywall detection, user preferences, and Room persistence. It implements the full extraction pipeline with graceful fallback.

Output: Updated CachedArticleDao with helper query, UserPreferencesRepository for settings, TextExtractionRepository with extractAndSave() function.
</objective>

<execution_context>
@C:\Users\lweis\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\lweis\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-text-extraction/02-RESEARCH.md
@app/src/main/java/com/newsthread/app/data/local/dao/CachedArticleDao.kt
@app/src/main/java/com/newsthread/app/data/local/entity/CachedArticleEntity.kt
@app/src/main/java/com/newsthread/app/di/DataStoreModule.kt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update CachedArticleDao with extraction helper query</name>
  <files>app/src/main/java/com/newsthread/app/data/local/dao/CachedArticleDao.kt</files>
  <action>
Add a new query method to CachedArticleDao for finding articles that need text extraction:

Add this method to the existing CachedArticleDao interface:

```kotlin
/**
 * Gets articles that need text extraction (fullText is null, not expired).
 * Used by background extraction workers to find work.
 * Ordered by fetchedAt DESC so newest articles are extracted first.
 */
@Query("""
    SELECT * FROM cached_articles
    WHERE fullText IS NULL
    AND expiresAt > :now
    ORDER BY fetchedAt DESC
""")
suspend fun getArticlesNeedingExtraction(now: Long = System.currentTimeMillis()): List<CachedArticleEntity>
```

This query:
- Filters to articles without extracted text (fullText IS NULL)
- Excludes expired articles (expiresAt > now)
- Orders newest first (most relevant for users)
  </action>
  <verify>CachedArticleDao compiles with new getArticlesNeedingExtraction method</verify>
  <done>CachedArticleDao has getArticlesNeedingExtraction() returning List<CachedArticleEntity> for articles without fullText</done>
</task>

<task type="auto">
  <name>Task 2: Create UserPreferencesRepository</name>
  <files>app/src/main/java/com/newsthread/app/data/repository/UserPreferencesRepository.kt</files>
  <action>
Create UserPreferencesRepository.kt - DataStore-backed repository for user preferences:

```kotlin
package com.newsthread.app.data.repository

import androidx.datastore.core.DataStore
import androidx.datastore.preferences.core.Preferences
import androidx.datastore.preferences.core.edit
import androidx.datastore.preferences.core.intPreferencesKey
import com.newsthread.app.domain.model.ArticleFetchPreference
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.map
import javax.inject.Inject
import javax.inject.Singleton

/**
 * Repository for user preferences stored in DataStore.
 *
 * Currently manages:
 * - Article fetch preference (WiFi-only / always / never)
 *
 * Future preferences (Phase 7+):
 * - Theme preference
 * - Notification settings
 * - Default news categories
 */
@Singleton
class UserPreferencesRepository @Inject constructor(
    private val dataStore: DataStore<Preferences>
) {
    /**
     * Flow of the user's article fetch preference.
     * Defaults to WIFI_ONLY (recommended setting for data-conscious users).
     */
    val articleFetchPreference: Flow<ArticleFetchPreference> = dataStore.data
        .map { preferences ->
            val ordinal = preferences[ARTICLE_FETCH_PREF_KEY]
                ?: ArticleFetchPreference.WIFI_ONLY.ordinal

            // Safely handle invalid ordinal values (e.g., from older app versions)
            ArticleFetchPreference.entries.getOrElse(ordinal) {
                ArticleFetchPreference.WIFI_ONLY
            }
        }

    /**
     * Updates the article fetch preference.
     *
     * @param preference New preference value
     */
    suspend fun setArticleFetchPreference(preference: ArticleFetchPreference) {
        dataStore.edit { preferences ->
            preferences[ARTICLE_FETCH_PREF_KEY] = preference.ordinal
        }
    }

    companion object {
        private val ARTICLE_FETCH_PREF_KEY = intPreferencesKey("article_fetch_preference")
    }
}
```

Design notes:
- Uses ordinal storage (int) for enum - simple and compact
- Default to WIFI_ONLY as recommended setting
- getOrElse handles potential invalid ordinals from future enum changes
- Singleton scope matches DataStore scope
  </action>
  <verify>File exists with @Inject constructor, articleFetchPreference Flow, and setArticleFetchPreference suspend function</verify>
  <done>UserPreferencesRepository exposes articleFetchPreference Flow and setArticleFetchPreference() for persistence</done>
</task>

<task type="auto">
  <name>Task 3: Create TextExtractionRepository</name>
  <files>app/src/main/java/com/newsthread/app/data/repository/TextExtractionRepository.kt</files>
  <action>
Create TextExtractionRepository.kt - orchestrates the full extraction pipeline:

```kotlin
package com.newsthread.app.data.repository

import android.util.Log
import com.newsthread.app.data.local.dao.CachedArticleDao
import com.newsthread.app.data.local.entity.CachedArticleEntity
import com.newsthread.app.data.remote.ArticleHtmlFetcher
import com.newsthread.app.domain.model.ArticleFetchPreference
import com.newsthread.app.domain.model.ExtractionResult
import com.newsthread.app.util.NetworkMonitor
import com.newsthread.app.util.PaywallDetector
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.withContext
import net.dankito.readability4j.extended.Readability4JExtended
import javax.inject.Inject
import javax.inject.Singleton

/**
 * Orchestrates article text extraction pipeline:
 * 1. Check user preference and network state
 * 2. Fetch HTML via ArticleHtmlFetcher
 * 3. Detect paywall indicators
 * 4. Extract content with Readability4J
 * 5. Save to Room via CachedArticleDao
 *
 * Provides graceful degradation at each step - caller can fall back to NewsAPI content.
 */
@Singleton
class TextExtractionRepository @Inject constructor(
    private val articleHtmlFetcher: ArticleHtmlFetcher,
    private val cachedArticleDao: CachedArticleDao,
    private val userPreferencesRepository: UserPreferencesRepository,
    private val networkMonitor: NetworkMonitor
) {
    /**
     * Extracts article text and saves to database.
     *
     * @param article Cached article entity to extract text for
     * @return ExtractionResult indicating outcome (success, paywall, error, or not fetched)
     *
     * On Success: Updates article.fullText in Room database
     * On Failure: Returns appropriate result type for caller to handle (e.g., use NewsAPI content)
     */
    suspend fun extractAndSave(article: CachedArticleEntity): ExtractionResult =
        withContext(Dispatchers.IO) {
            // Step 1: Check user preference and network state
            val preference = userPreferencesRepository.articleFetchPreference.first()

            if (!shouldFetch(preference)) {
                return@withContext ExtractionResult.NotFetched(
                    reason = when (preference) {
                        ArticleFetchPreference.NEVER -> "Article fetching disabled in settings"
                        ArticleFetchPreference.WIFI_ONLY -> "On metered network, WiFi-only mode enabled"
                        ArticleFetchPreference.ALWAYS -> "No network connection available"
                    }
                )
            }

            // Step 2: Fetch HTML
            val html = articleHtmlFetcher.fetch(article.url)
            if (html == null) {
                return@withContext ExtractionResult.NetworkError(
                    message = "Failed to fetch HTML from ${article.url}"
                )
            }

            // Step 3: Check for paywall indicators in raw HTML
            if (PaywallDetector.detectPaywall(html)) {
                Log.d(TAG, "Paywall detected for: ${article.url}")
                return@withContext ExtractionResult.PaywallDetected(
                    reason = "Paywall markers detected in HTML"
                )
            }

            // Step 4: Extract with Readability4J
            try {
                val readability = Readability4JExtended(article.url, html)
                val extracted = readability.parse()

                val textContent = extracted.textContent

                // Validate extraction quality
                if (textContent.isNullOrBlank()) {
                    return@withContext ExtractionResult.PaywallDetected(
                        reason = "Extraction returned empty content"
                    )
                }

                if (textContent.length < MIN_CONTENT_LENGTH) {
                    return@withContext ExtractionResult.PaywallDetected(
                        reason = "Extracted content too short (${textContent.length} chars, minimum $MIN_CONTENT_LENGTH)"
                    )
                }

                // Step 5: Save to Room
                cachedArticleDao.updateFullText(article.url, textContent)

                Log.d(TAG, "Extracted ${textContent.length} chars from: ${article.url}")

                ExtractionResult.Success(
                    textContent = textContent,
                    htmlContent = extracted.contentWithUtf8Encoding,
                    title = extracted.title,
                    byline = extracted.byline,
                    excerpt = extracted.excerpt
                )
            } catch (e: Exception) {
                Log.e(TAG, "Extraction failed for ${article.url}", e)
                ExtractionResult.ExtractionError(
                    message = e.message ?: "Unknown parsing error"
                )
            }
        }

    /**
     * Extracts text for a single article by URL.
     * Convenience method that loads the article from cache first.
     *
     * @param url Article URL to extract
     * @return ExtractionResult or NotFetched if article not in cache
     */
    suspend fun extractByUrl(url: String): ExtractionResult {
        val article = cachedArticleDao.getByUrl(url)
            ?: return ExtractionResult.NotFetched(reason = "Article not in cache")

        // Skip if already extracted
        if (!article.fullText.isNullOrBlank()) {
            return ExtractionResult.Success(
                textContent = article.fullText,
                htmlContent = null,
                title = article.title,
                byline = article.author,
                excerpt = article.description
            )
        }

        return extractAndSave(article)
    }

    /**
     * Gets articles that need extraction from cache.
     * Useful for background batch processing.
     */
    suspend fun getArticlesNeedingExtraction(): List<CachedArticleEntity> {
        return cachedArticleDao.getArticlesNeedingExtraction()
    }

    /**
     * Determines if fetching should proceed based on preference and network state.
     */
    private fun shouldFetch(preference: ArticleFetchPreference): Boolean {
        return when (preference) {
            ArticleFetchPreference.ALWAYS -> networkMonitor.isNetworkAvailable()
            ArticleFetchPreference.WIFI_ONLY -> networkMonitor.isCurrentlyOnWifi()
            ArticleFetchPreference.NEVER -> false
        }
    }

    companion object {
        private const val TAG = "TextExtractionRepository"

        /**
         * Minimum content length to consider extraction successful.
         * Articles shorter than this are likely paywalled or extraction failures.
         */
        private const val MIN_CONTENT_LENGTH = 100
    }
}
```

Design notes:
- All operations run on Dispatchers.IO
- Steps are numbered for clear pipeline flow
- Multiple return points for early exit on failure
- Logs extraction success with character count
- MIN_CONTENT_LENGTH (100) catches stub content
- extractByUrl() is convenience method for single-article use
- getArticlesNeedingExtraction() supports batch processing
  </action>
  <verify>File exists with extractAndSave(), extractByUrl(), getArticlesNeedingExtraction() methods; uses ArticleHtmlFetcher, Readability4JExtended, PaywallDetector, CachedArticleDao</verify>
  <done>TextExtractionRepository orchestrates full pipeline: preference check -> HTML fetch -> paywall detect -> Readability extract -> Room save</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `gradlew assembleDebug` compiles without errors
2. CachedArticleDao.getArticlesNeedingExtraction() query is valid SQL
3. UserPreferencesRepository reads/writes to DataStore
4. TextExtractionRepository can be injected with all dependencies
5. Readability4JExtended import resolves (from Plan 01 dependencies)
6. PaywallDetector import resolves (from Plan 01)
</verification>

<success_criteria>
- CachedArticleDao has query for articles needing extraction
- UserPreferencesRepository persists ArticleFetchPreference to DataStore
- TextExtractionRepository.extractAndSave() returns ExtractionResult with appropriate outcome
- Extraction respects user preference (NEVER/WIFI_ONLY/ALWAYS)
- Extracted text saved to Room via updateFullText()
- Build compiles successfully
</success_criteria>

<output>
After completion, create `.planning/phases/02-text-extraction/02-03-SUMMARY.md`
</output>
