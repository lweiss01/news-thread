---
phase: 02-text-extraction
plan: 03
type: execute
wave: 3
depends_on: ["02-01", "02-02"]
files_modified:
  - app/src/main/java/com/newsthread/app/data/repository/UserPreferencesRepository.kt
  - app/src/main/java/com/newsthread/app/data/repository/TextExtractionRepository.kt
  - app/src/main/java/com/newsthread/app/data/local/dao/CachedArticleDao.kt
  - app/src/main/java/com/newsthread/app/data/local/entity/CachedArticleEntity.kt
  - app/src/main/java/com/newsthread/app/data/local/AppDatabase.kt
  - app/src/main/java/com/newsthread/app/di/RepositoryModule.kt
autonomous: true
user_setup: []

must_haves:
  truths:
    - "User preference for article fetching persists across app restarts"
    - "TextExtractionRepository orchestrates fetch -> parse -> save pipeline"
    - "Extraction respects user's WiFi-only preference"
    - "Paywall detection prevents storing empty/stub content"
    - "Extraction falls back gracefully when fetch fails"
    - "Failed extractions are retried once on next view (per user decision)"
    - "Articles that fail twice are marked as permanently failed and not retried"
  artifacts:
    - path: "app/src/main/java/com/newsthread/app/data/repository/UserPreferencesRepository.kt"
      provides: "DataStore-backed preference storage"
      contains: "articleFetchPreference"
    - path: "app/src/main/java/com/newsthread/app/data/repository/TextExtractionRepository.kt"
      provides: "Extraction orchestration with retry logic"
      contains: "fun extractAndSave"
    - path: "app/src/main/java/com/newsthread/app/data/local/dao/CachedArticleDao.kt"
      provides: "Query for articles needing extraction and retry tracking"
      contains: "getArticlesNeedingExtraction"
    - path: "app/src/main/java/com/newsthread/app/data/local/entity/CachedArticleEntity.kt"
      provides: "Extraction failure tracking fields"
      contains: "extractionFailedAt"
    - path: "app/src/main/java/com/newsthread/app/data/local/AppDatabase.kt"
      provides: "Migration 2->3 for retry tracking columns"
      contains: "MIGRATION_2_3"
  key_links:
    - from: "TextExtractionRepository"
      to: "ArticleHtmlFetcher"
      via: "HTML fetch step"
      pattern: "articleHtmlFetcher\\.fetch"
    - from: "TextExtractionRepository"
      to: "Readability4JExtended"
      via: "Article parsing"
      pattern: "Readability4JExtended"
    - from: "TextExtractionRepository"
      to: "PaywallDetector"
      via: "Pre-extraction paywall check"
      pattern: "PaywallDetector\\.detectPaywall"
    - from: "TextExtractionRepository"
      to: "CachedArticleDao"
      via: "Save extracted text and track failures"
      pattern: "cachedArticleDao\\.(updateFullText|markExtractionFailed)"
    - from: "UserPreferencesRepository"
      to: "DataStore"
      via: "Preference persistence"
      pattern: "dataStore\\.data"
---

<objective>
Create the core extraction repositories: UserPreferencesRepository for fetch preference persistence, and TextExtractionRepository that orchestrates the full extraction pipeline (fetch HTML -> detect paywall -> parse with Readability4J -> save to Room).

Purpose: This is the heart of Phase 2 - connecting all the infrastructure (OkHttp, Readability4J, PaywallDetector, NetworkMonitor) into a working pipeline that respects user preferences and handles failures gracefully. Per user decision in CONTEXT.md, failed extractions are retried once on next view to handle transient failures.

Output:
- UserPreferencesRepository.kt with DataStore-backed ALWAYS/WIFI_ONLY/NEVER preference
- CachedArticleEntity.kt updated with extraction failure tracking fields
- AppDatabase.kt with MIGRATION_2_3 for retry tracking columns
- CachedArticleDao.kt updated with extraction queries and failure tracking methods
- TextExtractionRepository.kt that orchestrates extraction with retry-once logic
- RepositoryModule.kt updated with UserPreferencesRepository binding
</objective>

<execution_context>
@C:\Users\lweis\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\lweis\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-text-extraction/02-RESEARCH.md
@.planning/phases/02-text-extraction/02-CONTEXT.md

# Prior plan context
@.planning/phases/02-text-extraction/02-01-PLAN.md
@.planning/phases/02-text-extraction/02-02-PLAN.md

# Existing files to reference/modify
@app/src/main/java/com/newsthread/app/data/local/dao/CachedArticleDao.kt
@app/src/main/java/com/newsthread/app/data/local/entity/CachedArticleEntity.kt
@app/src/main/java/com/newsthread/app/data/local/AppDatabase.kt
@app/src/main/java/com/newsthread/app/di/RepositoryModule.kt
@app/src/main/java/com/newsthread/app/data/repository/QuotaRepository.kt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create UserPreferencesRepository</name>
  <files>app/src/main/java/com/newsthread/app/data/repository/UserPreferencesRepository.kt</files>
  <action>
Create UserPreferencesRepository that persists the article fetch preference to DataStore.

Key requirements:
- Inject DataStore<Preferences>
- Expose articleFetchPreference as Flow<ArticleFetchPreference>
- Default to WIFI_ONLY per user decision in 02-CONTEXT.md
- Provide setArticleFetchPreference() suspend function
- Use intPreferencesKey for enum ordinal storage

```kotlin
package com.newsthread.app.data.repository

import androidx.datastore.core.DataStore
import androidx.datastore.preferences.core.Preferences
import androidx.datastore.preferences.core.edit
import androidx.datastore.preferences.core.intPreferencesKey
import com.newsthread.app.domain.model.ArticleFetchPreference
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.map
import javax.inject.Inject
import javax.inject.Singleton

@Singleton
class UserPreferencesRepository @Inject constructor(
    private val dataStore: DataStore<Preferences>
) {
    /**
     * User's preference for when to fetch full article text.
     * Defaults to WIFI_ONLY (most conservative for new users).
     */
    val articleFetchPreference: Flow<ArticleFetchPreference> = dataStore.data
        .map { prefs ->
            val ordinal = prefs[ARTICLE_FETCH_PREF_KEY] ?: ArticleFetchPreference.WIFI_ONLY.ordinal
            ArticleFetchPreference.entries[ordinal]
        }

    /**
     * Updates the article fetch preference.
     *
     * @param preference New preference value (ALWAYS, WIFI_ONLY, or NEVER)
     */
    suspend fun setArticleFetchPreference(preference: ArticleFetchPreference) {
        dataStore.edit { prefs ->
            prefs[ARTICLE_FETCH_PREF_KEY] = preference.ordinal
        }
    }

    companion object {
        val ARTICLE_FETCH_PREF_KEY = intPreferencesKey("article_fetch_preference")
    }
}
```
  </action>
  <verify>
Grep for key patterns:
- "val articleFetchPreference: Flow<ArticleFetchPreference>"
- "WIFI_ONLY.ordinal" (default)
- "suspend fun setArticleFetchPreference"
- "dataStore.edit"
  </verify>
  <done>UserPreferencesRepository persists fetch preference to DataStore with WIFI_ONLY default</done>
</task>

<task type="auto">
  <name>Task 2: Add extraction failure tracking to CachedArticleEntity and database</name>
  <files>
    app/src/main/java/com/newsthread/app/data/local/entity/CachedArticleEntity.kt
    app/src/main/java/com/newsthread/app/data/local/AppDatabase.kt
    app/src/main/java/com/newsthread/app/data/local/dao/CachedArticleDao.kt
  </files>
  <action>
Add extraction failure tracking fields and database migration to support "retry once on next view" per 02-CONTEXT.md user decision.

**1. Update CachedArticleEntity.kt** - Add two fields for retry tracking:

```kotlin
package com.newsthread.app.data.local.entity

import androidx.room.Entity
import androidx.room.Index
import androidx.room.PrimaryKey

@Entity(
    tableName = "cached_articles",
    indices = [
        Index(value = ["fetchedAt"]),
        Index(value = ["sourceId"]),
        Index(value = ["publishedAt"])
    ]
)
data class CachedArticleEntity(
    @PrimaryKey
    val url: String,
    val sourceId: String?,
    val sourceName: String,
    val author: String?,
    val title: String,
    val description: String?,
    val urlToImage: String?,
    val publishedAt: String,
    val content: String?,           // NewsAPI truncated content
    val fullText: String?,          // Full article text (populated by Phase 2 text extraction)
    val fetchedAt: Long,            // System.currentTimeMillis() when fetched
    val expiresAt: Long,            // fetchedAt + TTL_MS
    // Extraction retry tracking (per 02-CONTEXT.md: "Retry once on next view")
    val extractionFailedAt: Long? = null,  // Timestamp of last extraction failure, null if never failed
    val extractionRetryCount: Int = 0      // 0=never tried/succeeded, 1=failed once (eligible for retry), 2+=permanently failed
)
```

**2. Update AppDatabase.kt** - Add MIGRATION_2_3 and bump version to 3:

In the @Database annotation, change version to 3.

Add the migration after MIGRATION_1_2:

```kotlin
/**
 * Migration from version 2 to 3.
 * Adds extraction retry tracking columns to cached_articles.
 * Per user decision: "Retry once on next view (handles transient failures)"
 */
val MIGRATION_2_3 = object : Migration(2, 3) {
    override fun migrate(db: SupportSQLiteDatabase) {
        // Add extraction failure tracking columns
        db.execSQL("ALTER TABLE cached_articles ADD COLUMN extractionFailedAt INTEGER DEFAULT NULL")
        db.execSQL("ALTER TABLE cached_articles ADD COLUMN extractionRetryCount INTEGER NOT NULL DEFAULT 0")
    }
}
```

Update getDatabase() to add the new migration:
```kotlin
.addMigrations(MIGRATION_1_2, MIGRATION_2_3)
```

**3. Update CachedArticleDao.kt** - Add extraction tracking methods:

Add these methods to the existing interface:

```kotlin
/**
 * Gets articles that need text extraction (fullText is null and article not expired).
 * Excludes articles that have permanently failed (retryCount >= 2).
 * Orders by fetchedAt DESC to prioritize recently fetched articles.
 *
 * @param now Current timestamp for expiry check
 * @param limit Maximum number of articles to return (for batch processing)
 * @return List of articles needing extraction
 */
@Query("""
    SELECT * FROM cached_articles
    WHERE fullText IS NULL
    AND expiresAt > :now
    AND extractionRetryCount < 2
    ORDER BY fetchedAt DESC
    LIMIT :limit
""")
suspend fun getArticlesNeedingExtraction(
    now: Long = System.currentTimeMillis(),
    limit: Int = 10
): List<CachedArticleEntity>

/**
 * Marks an article's extraction as failed.
 * Increments retry count and records failure timestamp.
 *
 * @param url Article URL
 * @param failedAt Timestamp of failure
 */
@Query("""
    UPDATE cached_articles
    SET extractionFailedAt = :failedAt,
        extractionRetryCount = extractionRetryCount + 1
    WHERE url = :url
""")
suspend fun markExtractionFailed(url: String, failedAt: Long = System.currentTimeMillis())

/**
 * Clears extraction failure state for an article (on successful extraction).
 *
 * @param url Article URL
 */
@Query("UPDATE cached_articles SET extractionFailedAt = NULL, extractionRetryCount = 0 WHERE url = :url")
suspend fun clearExtractionFailure(url: String)

/**
 * Checks if an article is eligible for extraction retry.
 * Eligible if: failed once (retryCount = 1) and enough time has passed (>= 5 minutes).
 *
 * @param url Article URL
 * @param minTimeSinceFailure Minimum milliseconds since failure before retry (default 5 min)
 * @param now Current timestamp
 * @return True if article should be retried
 */
@Query("""
    SELECT CASE
        WHEN extractionRetryCount = 1
        AND extractionFailedAt IS NOT NULL
        AND (:now - extractionFailedAt) >= :minTimeSinceFailure
        THEN 1 ELSE 0 END
    FROM cached_articles
    WHERE url = :url
""")
suspend fun isRetryEligible(
    url: String,
    minTimeSinceFailure: Long = 5 * 60 * 1000L, // 5 minutes
    now: Long = System.currentTimeMillis()
): Boolean
```
  </action>
  <verify>
Grep for key patterns:
- CachedArticleEntity.kt: "extractionFailedAt: Long?" and "extractionRetryCount: Int"
- AppDatabase.kt: "MIGRATION_2_3" and "version = 3"
- CachedArticleDao.kt: "fun markExtractionFailed" and "fun isRetryEligible" and "extractionRetryCount < 2"
  </verify>
  <done>
- CachedArticleEntity has extractionFailedAt and extractionRetryCount fields
- AppDatabase has MIGRATION_2_3 adding the columns
- CachedArticleDao has markExtractionFailed, clearExtractionFailure, and isRetryEligible methods
- getArticlesNeedingExtraction excludes permanently failed articles (retryCount >= 2)
  </done>
</task>

<task type="auto">
  <name>Task 3: Create TextExtractionRepository with retry-once logic</name>
  <files>app/src/main/java/com/newsthread/app/data/repository/TextExtractionRepository.kt</files>
  <action>
Create TextExtractionRepository that orchestrates the full extraction pipeline with retry-once logic per 02-CONTEXT.md user decision: "Retry once on next view (handles transient failures without wasting resources)".

Key requirements:
- Inject ArticleHtmlFetcher, CachedArticleDao, UserPreferencesRepository, NetworkMonitor
- Check user preference and network state before fetching
- Check for paywall before parsing
- Use Readability4JExtended for parsing
- Minimum content length threshold: 100 chars
- Save extracted text to Room via CachedArticleDao.updateFullText
- **Retry logic:** On failure, mark article with extractionRetryCount++. On next view, if retry-eligible (count=1, >5min elapsed), retry once. If retry fails, mark permanently failed (count=2+).
- On success, clear failure state
- Return ExtractionResult for type-safe handling

```kotlin
package com.newsthread.app.data.repository

import android.util.Log
import com.newsthread.app.data.local.dao.CachedArticleDao
import com.newsthread.app.data.local.entity.CachedArticleEntity
import com.newsthread.app.data.remote.ArticleHtmlFetcher
import com.newsthread.app.domain.model.ArticleFetchPreference
import com.newsthread.app.domain.model.ExtractionResult
import com.newsthread.app.util.NetworkMonitor
import com.newsthread.app.util.PaywallDetector
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.withContext
import net.dankito.readability4j.extended.Readability4JExtended
import javax.inject.Inject
import javax.inject.Singleton

@Singleton
class TextExtractionRepository @Inject constructor(
    private val articleHtmlFetcher: ArticleHtmlFetcher,
    private val cachedArticleDao: CachedArticleDao,
    private val userPreferencesRepository: UserPreferencesRepository,
    private val networkMonitor: NetworkMonitor
) {
    /**
     * Extracts article text and saves it to the database.
     * Implements "retry once on next view" per user decision in 02-CONTEXT.md.
     *
     * Flow:
     * 1. Check if this is a retry-eligible article (failed once, >5min ago)
     * 2. Check user preference and network state
     * 3. Fetch HTML via ArticleHtmlFetcher
     * 4. Check for paywall indicators
     * 5. Parse with Readability4JExtended
     * 6. Validate content quality
     * 7. Save to Room (on success) or mark failed (on failure)
     *
     * @param article Cached article entity to extract text for
     * @return ExtractionResult indicating success or failure type
     */
    suspend fun extractAndSave(article: CachedArticleEntity): ExtractionResult = withContext(Dispatchers.IO) {
        // Step 0: Check retry eligibility for previously failed articles
        if (article.extractionRetryCount >= 2) {
            // Permanently failed - don't retry
            Log.d(TAG, "Skipping permanently failed article: ${article.url}")
            return@withContext ExtractionResult.ExtractionError(
                "Article permanently failed after retry (extractionRetryCount=${article.extractionRetryCount})"
            )
        }

        if (article.extractionRetryCount == 1) {
            // Failed once - check if eligible for retry (>5min since failure)
            val isEligible = cachedArticleDao.isRetryEligible(article.url)
            if (!isEligible) {
                Log.d(TAG, "Article not yet eligible for retry: ${article.url}")
                return@withContext ExtractionResult.NotFetched(
                    reason = "Extraction failed recently, waiting for retry window"
                )
            }
            Log.d(TAG, "Retrying previously failed article: ${article.url}")
        }

        // Step 1: Check user preference
        val preference = userPreferencesRepository.articleFetchPreference.first()

        if (!shouldFetch(preference)) {
            return@withContext ExtractionResult.NotFetched(
                reason = when (preference) {
                    ArticleFetchPreference.NEVER -> "Article fetching disabled in settings"
                    ArticleFetchPreference.WIFI_ONLY -> "On metered network, WiFi-only enabled"
                    ArticleFetchPreference.ALWAYS -> "No network available"
                }
            )
        }

        // Step 2: Fetch HTML
        val html = articleHtmlFetcher.fetch(article.url)
        if (html == null) {
            // Mark as failed for retry tracking
            cachedArticleDao.markExtractionFailed(article.url)
            Log.w(TAG, "Failed to fetch HTML, marked for retry: ${article.url}")
            return@withContext ExtractionResult.NetworkError("Failed to fetch HTML from ${article.url}")
        }

        // Step 3: Check for paywall indicators
        if (PaywallDetector.detectPaywall(html)) {
            // Paywall is a permanent failure - mark with high retry count to skip future attempts
            cachedArticleDao.markExtractionFailed(article.url)
            cachedArticleDao.markExtractionFailed(article.url) // Increment twice to mark permanent
            Log.w(TAG, "Paywall detected, marked as permanently failed: ${article.url}")
            return@withContext ExtractionResult.PaywallDetected(
                reason = "Paywall markers detected in HTML"
            )
        }

        // Step 4 & 5: Parse with Readability4J and validate
        try {
            val readability = Readability4JExtended(article.url, html)
            val extracted = readability.parse()

            val textContent = extracted.textContent
            if (textContent.isNullOrBlank() || textContent.length < MIN_CONTENT_LENGTH) {
                // Content too short - likely JS-rendered or partial paywall
                cachedArticleDao.markExtractionFailed(article.url)
                Log.w(TAG, "Extracted content too short (${textContent?.length ?: 0} chars), marked for retry: ${article.url}")
                return@withContext ExtractionResult.PaywallDetected(
                    reason = "Extracted content too short (${textContent?.length ?: 0} chars), likely paywalled or JS-rendered"
                )
            }

            // Step 6: Save to Room and clear any failure state
            cachedArticleDao.updateFullText(article.url, textContent)
            cachedArticleDao.clearExtractionFailure(article.url)
            Log.d(TAG, "Successfully extracted ${textContent.length} chars for: ${article.url}")

            ExtractionResult.Success(
                textContent = textContent,
                htmlContent = extracted.contentWithUtf8Encoding,
                title = extracted.title,
                byline = extracted.byline,
                excerpt = extracted.excerpt
            )
        } catch (e: Exception) {
            // Parsing error - mark for retry
            cachedArticleDao.markExtractionFailed(article.url)
            Log.e(TAG, "Extraction failed, marked for retry: ${article.url}", e)
            ExtractionResult.ExtractionError(e.message ?: "Unknown parsing error")
        }
    }

    /**
     * Extracts text for a single article by URL.
     * Convenience method that looks up the article first.
     *
     * @param url Article URL
     * @return ExtractionResult, or NetworkError if article not found in cache
     */
    suspend fun extractByUrl(url: String): ExtractionResult {
        val article = cachedArticleDao.getByUrl(url)
            ?: return ExtractionResult.NetworkError("Article not found in cache: $url")
        return extractAndSave(article)
    }

    /**
     * Batch extracts articles that need extraction.
     * Useful for background processing.
     * Excludes permanently failed articles (extractionRetryCount >= 2).
     *
     * @param limit Maximum articles to process
     * @return Map of URL to ExtractionResult
     */
    suspend fun extractBatch(limit: Int = 10): Map<String, ExtractionResult> {
        val articles = cachedArticleDao.getArticlesNeedingExtraction(limit = limit)
        return articles.associate { article ->
            article.url to extractAndSave(article)
        }
    }

    private fun shouldFetch(preference: ArticleFetchPreference): Boolean {
        return when (preference) {
            ArticleFetchPreference.ALWAYS -> networkMonitor.isNetworkAvailable()
            ArticleFetchPreference.WIFI_ONLY -> networkMonitor.isCurrentlyOnWifi()
            ArticleFetchPreference.NEVER -> false
        }
    }

    companion object {
        private const val TAG = "TextExtractionRepository"
        private const val MIN_CONTENT_LENGTH = 100
    }
}
```
  </action>
  <verify>
Grep for key patterns:
- "suspend fun extractAndSave"
- "articleHtmlFetcher.fetch"
- "PaywallDetector.detectPaywall"
- "Readability4JExtended"
- "cachedArticleDao.updateFullText"
- "cachedArticleDao.markExtractionFailed"
- "cachedArticleDao.clearExtractionFailure"
- "cachedArticleDao.isRetryEligible"
- "extractionRetryCount >= 2" (permanent failure check)
- "MIN_CONTENT_LENGTH = 100"
  </verify>
  <done>
- TextExtractionRepository orchestrates fetch -> paywall check -> parse -> save pipeline
- Implements "retry once on next view" per user decision:
  - On first failure: marks article with extractionRetryCount=1
  - On next view (>5min later): retries the extraction
  - On second failure: marks permanent (count=2+), never retried again
  - On success: clears failure state
- Paywall detection marks articles as permanently failed (skips retry)
  </done>
</task>

</tasks>

<verification>
After completing all tasks:

1. Verify UserPreferencesRepository:
   - Grep for "val articleFetchPreference: Flow"
   - Grep for "suspend fun setArticleFetchPreference"
   - Grep for "WIFI_ONLY.ordinal" (default)

2. Verify CachedArticleEntity update:
   - Grep for "extractionFailedAt: Long?"
   - Grep for "extractionRetryCount: Int"

3. Verify AppDatabase migration:
   - Grep for "version = 3"
   - Grep for "MIGRATION_2_3"
   - Grep for "ADD COLUMN extractionFailedAt"

4. Verify CachedArticleDao update:
   - Grep for "fun getArticlesNeedingExtraction"
   - Grep for "extractionRetryCount < 2" (excludes permanently failed)
   - Grep for "fun markExtractionFailed"
   - Grep for "fun isRetryEligible"

5. Verify TextExtractionRepository:
   - Grep for "suspend fun extractAndSave"
   - Grep for "articleHtmlFetcher.fetch"
   - Grep for "Readability4JExtended"
   - Grep for "PaywallDetector.detectPaywall"
   - Grep for "cachedArticleDao.updateFullText"
   - Grep for "cachedArticleDao.markExtractionFailed"
   - Grep for "extractionRetryCount >= 2"

6. Verify pipeline connections:
   - TextExtractionRepository imports ArticleHtmlFetcher
   - TextExtractionRepository imports PaywallDetector
   - TextExtractionRepository imports UserPreferencesRepository
   - TextExtractionRepository imports NetworkMonitor
</verification>

<success_criteria>
- UserPreferencesRepository persists ALWAYS/WIFI_ONLY/NEVER to DataStore with WIFI_ONLY default
- CachedArticleEntity has extractionFailedAt and extractionRetryCount fields
- AppDatabase version bumped to 3 with MIGRATION_2_3
- CachedArticleDao.getArticlesNeedingExtraction excludes permanently failed articles (retryCount >= 2)
- CachedArticleDao has markExtractionFailed and isRetryEligible methods
- TextExtractionRepository.extractAndSave orchestrates full pipeline
- TextExtractionRepository respects user preference and network state
- TextExtractionRepository implements "retry once on next view" per user decision:
  - Failed articles marked with timestamp and retry count
  - Eligible for retry after 5 minutes
  - Second failure marks article as permanently failed
  - Success clears failure state
- TextExtractionRepository detects paywalls and marks them as permanently failed
- All error cases return appropriate ExtractionResult variant
</success_criteria>

<output>
After completion, create `.planning/phases/02-text-extraction/02-03-SUMMARY.md`
</output>
