---
phase: 02-text-extraction
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - app/src/main/java/com/newsthread/app/data/remote/di/ArticleFetchModule.kt
  - app/src/main/java/com/newsthread/app/data/remote/ArticleHtmlFetcher.kt
  - app/src/main/java/com/newsthread/app/util/NetworkMonitor.kt
autonomous: true

must_haves:
  truths:
    - "Article HTML is fetched via dedicated OkHttp client with 7-day cache"
    - "Network state (WiFi vs metered) is observable via Flow"
    - "Article fetcher handles 404, 403, timeouts gracefully"
  artifacts:
    - path: "app/src/main/java/com/newsthread/app/data/remote/di/ArticleFetchModule.kt"
      provides: "Separate OkHttpClient for article HTML with 7-day cache"
      contains: "@ArticleHtmlClient"
    - path: "app/src/main/java/com/newsthread/app/data/remote/ArticleHtmlFetcher.kt"
      provides: "Fetches article HTML with error handling"
      contains: "suspend fun fetch"
    - path: "app/src/main/java/com/newsthread/app/util/NetworkMonitor.kt"
      provides: "WiFi vs metered network detection"
      contains: "isCurrentlyOnWifi"
  key_links:
    - from: "ArticleHtmlFetcher"
      to: "@ArticleHtmlClient OkHttpClient"
      via: "Hilt injection"
      pattern: "@ArticleHtmlClient.*OkHttpClient"
    - from: "NetworkMonitor"
      to: "ConnectivityManager"
      via: "NetworkCallback"
      pattern: "registerNetworkCallback"
---

<objective>
Create network infrastructure for article HTML fetching with separate caching

Purpose: The article HTML fetcher needs a dedicated OkHttp client (separate from NewsAPI) with 7-day cache TTL and article-specific timeouts. The network monitor enables respecting user's WiFi-only preference.

Output: ArticleFetchModule (Hilt DI module), ArticleHtmlFetcher (suspend function for HTML fetch), NetworkMonitor (WiFi detection utility).
</objective>

<execution_context>
@C:\Users\lweis\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\lweis\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-text-extraction/02-RESEARCH.md
@app/src/main/java/com/newsthread/app/data/remote/di/NetworkModule.kt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ArticleFetchModule with dedicated OkHttpClient</name>
  <files>app/src/main/java/com/newsthread/app/data/remote/di/ArticleFetchModule.kt</files>
  <action>
Create ArticleFetchModule.kt - Hilt module providing a separate OkHttpClient for article HTML fetching:

```kotlin
package com.newsthread.app.data.remote.di

import android.content.Context
import dagger.Module
import dagger.Provides
import dagger.hilt.InstallIn
import dagger.hilt.android.qualifiers.ApplicationContext
import dagger.hilt.components.SingletonComponent
import okhttp3.Cache
import okhttp3.CacheControl
import okhttp3.OkHttpClient
import java.io.File
import java.util.concurrent.TimeUnit
import javax.inject.Qualifier
import javax.inject.Singleton

/**
 * Qualifier annotation to distinguish article HTML OkHttpClient from NewsAPI client.
 */
@Qualifier
@Retention(AnnotationRetention.BINARY)
annotation class ArticleHtmlClient

@Module
@InstallIn(SingletonComponent::class)
object ArticleFetchModule {

    /**
     * Provides a dedicated OkHttpClient for fetching article HTML.
     *
     * Key differences from NewsAPI client:
     * - 7-day cache TTL (vs 3-hour for feeds)
     * - 100 MiB cache size (articles can be large)
     * - Browser-like User-Agent to avoid bot blocking
     * - Longer read timeout (30s) for slow news sites
     * - No API key interceptor (fetching public URLs)
     */
    @Provides
    @Singleton
    @ArticleHtmlClient
    fun provideArticleOkHttpClient(
        @ApplicationContext context: Context
    ): OkHttpClient {
        // Separate cache directory from NewsAPI cache
        val cacheSize = 100L * 1024L * 1024L // 100 MiB for article HTML
        val cache = Cache(
            directory = File(context.cacheDir, "article_html_cache"),
            maxSize = cacheSize
        )

        return OkHttpClient.Builder()
            .cache(cache)
            .connectTimeout(15, TimeUnit.SECONDS)
            .readTimeout(30, TimeUnit.SECONDS)  // Articles can be large/slow
            .writeTimeout(15, TimeUnit.SECONDS)
            // Force 7-day cache for article HTML
            .addNetworkInterceptor { chain ->
                val response = chain.proceed(chain.request())

                // Only cache successful responses
                if (response.isSuccessful) {
                    val cacheControl = CacheControl.Builder()
                        .maxAge(7, TimeUnit.DAYS)
                        .build()

                    response.newBuilder()
                        .header("Cache-Control", cacheControl.toString())
                        .removeHeader("Pragma")
                        .removeHeader("Expires")
                        .build()
                } else {
                    response
                }
            }
            // Add browser-like User-Agent to avoid bot blocking
            .addInterceptor { chain ->
                val request = chain.request().newBuilder()
                    .header("User-Agent", "Mozilla/5.0 (Linux; Android 14) NewsThread/1.0")
                    .header("Accept", "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8")
                    .header("Accept-Language", "en-US,en;q=0.5")
                    .build()
                chain.proceed(request)
            }
            .build()
    }
}
```

Key design decisions:
- Separate cache directory (`article_html_cache`) prevents eviction conflicts with NewsAPI cache
- 7-day max-age per Phase 2 requirements
- Browser-like headers avoid 403 from anti-bot systems
- No logging interceptor (HTML bodies are large, would flood logs)
  </action>
  <verify>File exists with @ArticleHtmlClient qualifier and @Provides method returning OkHttpClient</verify>
  <done>ArticleFetchModule provides @ArticleHtmlClient-qualified OkHttpClient with 7-day cache, 100 MiB size, browser User-Agent</done>
</task>

<task type="auto">
  <name>Task 2: Create ArticleHtmlFetcher</name>
  <files>app/src/main/java/com/newsthread/app/data/remote/ArticleHtmlFetcher.kt</files>
  <action>
Create ArticleHtmlFetcher.kt - suspending HTML fetcher with comprehensive error handling:

```kotlin
package com.newsthread.app.data.remote

import android.util.Log
import com.newsthread.app.data.remote.di.ArticleHtmlClient
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import okhttp3.OkHttpClient
import okhttp3.Request
import java.io.IOException
import java.net.SocketTimeoutException
import java.net.UnknownHostException
import javax.inject.Inject
import javax.inject.Singleton

/**
 * Fetches article HTML content using the dedicated article OkHttpClient.
 *
 * Uses OkHttp instead of jsoup.connect() for:
 * - Integration with 7-day cache
 * - Proper timeout handling
 * - Browser-like headers (configured in ArticleFetchModule)
 */
@Singleton
class ArticleHtmlFetcher @Inject constructor(
    @ArticleHtmlClient private val okHttpClient: OkHttpClient
) {
    /**
     * Fetches HTML content from the given URL.
     *
     * @param url Article URL to fetch
     * @return HTML string if successful, null if any error occurs
     *
     * Handles:
     * - 404 Not Found (article removed)
     * - 403/401 Forbidden (paywall or geo-blocked)
     * - Timeouts (slow servers)
     * - Network errors (no connection)
     */
    suspend fun fetch(url: String): String? = withContext(Dispatchers.IO) {
        try {
            val request = Request.Builder()
                .url(url)
                .build()

            val response = okHttpClient.newCall(request).execute()

            when {
                response.isSuccessful -> {
                    response.body?.string()
                }
                response.code == 404 -> {
                    Log.w(TAG, "Article not found (404): $url")
                    null
                }
                response.code == 403 || response.code == 401 -> {
                    Log.w(TAG, "Access denied (${response.code}), possible paywall: $url")
                    null
                }
                response.code == 410 -> {
                    Log.w(TAG, "Article permanently removed (410): $url")
                    null
                }
                response.code >= 500 -> {
                    Log.w(TAG, "Server error (${response.code}): $url")
                    null
                }
                else -> {
                    Log.e(TAG, "HTTP ${response.code} for: $url")
                    null
                }
            }
        } catch (e: SocketTimeoutException) {
            Log.e(TAG, "Timeout fetching: $url", e)
            null
        } catch (e: UnknownHostException) {
            Log.e(TAG, "Unknown host (offline?): $url", e)
            null
        } catch (e: IOException) {
            Log.e(TAG, "Network error fetching: $url", e)
            null
        } catch (e: Exception) {
            Log.e(TAG, "Unexpected error fetching: $url", e)
            null
        }
    }

    companion object {
        private const val TAG = "ArticleHtmlFetcher"
    }
}
```

Design notes:
- Returns null for all error cases (caller uses ExtractionResult for differentiation)
- Logs errors with different levels (w for expected, e for unexpected)
- Uses Dispatchers.IO for blocking network call
- Singleton scope matches OkHttpClient scope
  </action>
  <verify>File exists with @Inject constructor receiving @ArticleHtmlClient OkHttpClient and suspend fun fetch(url: String): String?</verify>
  <done>ArticleHtmlFetcher.fetch(url) returns HTML string or null with appropriate logging for each error type</done>
</task>

<task type="auto">
  <name>Task 3: Create NetworkMonitor utility</name>
  <files>app/src/main/java/com/newsthread/app/util/NetworkMonitor.kt</files>
  <action>
Create NetworkMonitor.kt - reactive network state monitoring with WiFi detection:

```kotlin
package com.newsthread.app.util

import android.content.Context
import android.net.ConnectivityManager
import android.net.Network
import android.net.NetworkCapabilities
import android.net.NetworkRequest
import dagger.hilt.android.qualifiers.ApplicationContext
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.SupervisorJob
import kotlinx.coroutines.channels.awaitClose
import kotlinx.coroutines.flow.SharingStarted
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.callbackFlow
import kotlinx.coroutines.flow.stateIn
import javax.inject.Inject
import javax.inject.Singleton

/**
 * Monitors network connectivity state with focus on WiFi vs metered detection.
 *
 * Provides both reactive (Flow) and synchronous (function) access to network state
 * for different use cases:
 * - Flow: UI observation, background workers that need updates
 * - Functions: One-shot checks before initiating network requests
 */
@Singleton
class NetworkMonitor @Inject constructor(
    @ApplicationContext private val context: Context
) {
    private val connectivityManager =
        context.getSystemService(Context.CONNECTIVITY_SERVICE) as ConnectivityManager

    private val scope = CoroutineScope(SupervisorJob() + Dispatchers.Default)

    /**
     * StateFlow of current WiFi connection status.
     * Emits true when connected to unmetered network (WiFi/Ethernet) with internet.
     */
    val isWifiConnected: StateFlow<Boolean> = callbackFlow {
        val callback = object : ConnectivityManager.NetworkCallback() {
            override fun onCapabilitiesChanged(
                network: Network,
                capabilities: NetworkCapabilities
            ) {
                val isUnmetered = !capabilities.hasCapability(
                    NetworkCapabilities.NET_CAPABILITY_NOT_METERED
                ).not() // Double negative: has NOT_METERED = true means unmetered

                val isWifi = capabilities.hasTransport(NetworkCapabilities.TRANSPORT_WIFI) ||
                             capabilities.hasTransport(NetworkCapabilities.TRANSPORT_ETHERNET)
                val hasInternet = capabilities.hasCapability(
                    NetworkCapabilities.NET_CAPABILITY_VALIDATED
                )

                trySend(isWifi && hasInternet)
            }

            override fun onLost(network: Network) {
                // Check if there's still an active network
                trySend(isCurrentlyOnWifi())
            }

            override fun onUnavailable() {
                trySend(false)
            }
        }

        val request = NetworkRequest.Builder()
            .addCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET)
            .build()

        connectivityManager.registerNetworkCallback(request, callback)

        // Emit initial state
        trySend(isCurrentlyOnWifi())

        awaitClose {
            connectivityManager.unregisterNetworkCallback(callback)
        }
    }.stateIn(
        scope = scope,
        started = SharingStarted.WhileSubscribed(5000),
        initialValue = isCurrentlyOnWifi()
    )

    /**
     * Synchronously checks if currently connected to WiFi/Ethernet with internet.
     * Use for one-shot checks before initiating requests.
     */
    fun isCurrentlyOnWifi(): Boolean {
        val network = connectivityManager.activeNetwork ?: return false
        val capabilities = connectivityManager.getNetworkCapabilities(network) ?: return false

        val isWifi = capabilities.hasTransport(NetworkCapabilities.TRANSPORT_WIFI) ||
                     capabilities.hasTransport(NetworkCapabilities.TRANSPORT_ETHERNET)
        val hasInternet = capabilities.hasCapability(NetworkCapabilities.NET_CAPABILITY_VALIDATED)

        return isWifi && hasInternet
    }

    /**
     * Synchronously checks if any network with internet is available.
     * Use for general connectivity checks (regardless of metered status).
     */
    fun isNetworkAvailable(): Boolean {
        val network = connectivityManager.activeNetwork ?: return false
        val capabilities = connectivityManager.getNetworkCapabilities(network) ?: return false
        return capabilities.hasCapability(NetworkCapabilities.NET_CAPABILITY_VALIDATED)
    }

    /**
     * Synchronously checks if the current network is metered (cellular data).
     * Returns false if no network or on WiFi.
     */
    fun isMeteredConnection(): Boolean {
        val network = connectivityManager.activeNetwork ?: return false
        val capabilities = connectivityManager.getNetworkCapabilities(network) ?: return false
        return !capabilities.hasCapability(NetworkCapabilities.NET_CAPABILITY_NOT_METERED)
    }
}
```

Design notes:
- StateFlow for reactive observation (UI/workers)
- Synchronous functions for one-shot checks (before fetch)
- Checks TRANSPORT_WIFI || TRANSPORT_ETHERNET for WiFi (Ethernet counts as unmetered)
- Checks NET_CAPABILITY_VALIDATED for actual internet connectivity
- WhileSubscribed(5000) keeps callback alive briefly after last collector
  </action>
  <verify>File exists with @Inject constructor, isWifiConnected StateFlow, isCurrentlyOnWifi(), isNetworkAvailable(), isMeteredConnection() functions</verify>
  <done>NetworkMonitor provides reactive isWifiConnected Flow and synchronous network state check functions</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `gradlew assembleDebug` compiles without errors
2. ArticleFetchModule provides @ArticleHtmlClient-qualified OkHttpClient
3. ArticleHtmlFetcher can be injected and uses @ArticleHtmlClient OkHttpClient
4. NetworkMonitor uses ConnectivityManager with NetworkCallback
5. No circular dependencies introduced
</verification>

<success_criteria>
- Separate OkHttpClient for article HTML with 7-day cache TTL
- ArticleHtmlFetcher handles 404, 403, 410, 5xx, timeouts gracefully
- NetworkMonitor detects WiFi vs metered connection
- All classes are injectable via Hilt
- Build compiles successfully
</success_criteria>

<output>
After completion, create `.planning/phases/02-text-extraction/02-02-SUMMARY.md`
</output>
