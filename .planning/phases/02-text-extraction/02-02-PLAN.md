---
phase: 02-text-extraction
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - app/src/main/java/com/newsthread/app/data/remote/di/ArticleFetchModule.kt
  - app/src/main/java/com/newsthread/app/data/remote/ArticleHtmlFetcher.kt
  - app/src/main/java/com/newsthread/app/util/NetworkMonitor.kt
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Separate OkHttpClient exists for article HTML with 7-day cache TTL"
    - "ArticleHtmlFetcher fetches HTML via OkHttp with proper User-Agent and error handling"
    - "NetworkMonitor detects WiFi vs metered network state"
  artifacts:
    - path: "app/src/main/java/com/newsthread/app/data/remote/di/ArticleFetchModule.kt"
      provides: "DI module with ArticleHtmlClient OkHttpClient"
      contains: "@ArticleHtmlClient"
    - path: "app/src/main/java/com/newsthread/app/data/remote/ArticleHtmlFetcher.kt"
      provides: "HTML fetching with OkHttp"
      contains: "class ArticleHtmlFetcher"
    - path: "app/src/main/java/com/newsthread/app/util/NetworkMonitor.kt"
      provides: "WiFi/metered network detection"
      contains: "fun isCurrentlyOnWifi"
  key_links:
    - from: "ArticleHtmlFetcher"
      to: "ArticleHtmlClient OkHttpClient"
      via: "Hilt qualifier injection"
      pattern: "@ArticleHtmlClient"
    - from: "ArticleFetchModule"
      to: "OkHttp Cache"
      via: "7-day max-age CacheControl"
      pattern: "maxAge\\(7.*DAYS\\)"
---

<objective>
Create network infrastructure for article HTML fetching: a separate OkHttpClient with 7-day cache, an ArticleHtmlFetcher that handles HTTP errors gracefully, and a NetworkMonitor for WiFi/metered detection.

Purpose: The article HTML needs different caching than NewsAPI (7 days vs 3 hours), and fetching must respect user's WiFi-only preference. This infrastructure enables conditional fetching with proper error handling.

Output:
- ArticleFetchModule.kt with @ArticleHtmlClient qualified OkHttpClient (100 MiB cache, 7-day TTL)
- ArticleHtmlFetcher.kt that fetches HTML with User-Agent, handles 404/403/timeout
- NetworkMonitor.kt that observes WiFi vs metered connection state
</objective>

<execution_context>
@C:\Users\lweis\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\lweis\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-text-extraction/02-RESEARCH.md

# Prior plan context
@.planning/phases/02-text-extraction/02-01-PLAN.md

# Existing network module for reference
@app/src/main/java/com/newsthread/app/data/remote/di/NetworkModule.kt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ArticleFetchModule with qualified OkHttpClient</name>
  <files>app/src/main/java/com/newsthread/app/data/remote/di/ArticleFetchModule.kt</files>
  <action>
Create a new Hilt module that provides a separate OkHttpClient for article HTML fetching, distinct from the NewsAPI client.

Key requirements:
- Use @ArticleHtmlClient qualifier annotation to distinguish from default OkHttpClient
- Cache size: 100 MiB (larger than NewsAPI's 50 MiB since articles are bigger)
- Cache directory: "article_html_cache" (separate from http_cache)
- 7-day cache TTL via CacheControl in network interceptor
- User-Agent header: "Mozilla/5.0 (Linux; Android 14) NewsThread/1.0"
- Connect timeout: 15 seconds
- Read timeout: 30 seconds (articles can be large)

```kotlin
package com.newsthread.app.data.remote.di

import android.content.Context
import dagger.Module
import dagger.Provides
import dagger.hilt.InstallIn
import dagger.hilt.android.qualifiers.ApplicationContext
import dagger.hilt.components.SingletonComponent
import okhttp3.Cache
import okhttp3.CacheControl
import okhttp3.OkHttpClient
import java.io.File
import java.util.concurrent.TimeUnit
import javax.inject.Qualifier
import javax.inject.Singleton

@Qualifier
@Retention(AnnotationRetention.BINARY)
annotation class ArticleHtmlClient

@Module
@InstallIn(SingletonComponent::class)
object ArticleFetchModule {

    @Provides
    @Singleton
    @ArticleHtmlClient
    fun provideArticleOkHttpClient(
        @ApplicationContext context: Context
    ): OkHttpClient {
        // Separate cache for article HTML (distinct from NewsAPI cache)
        val cacheSize = 100L * 1024L * 1024L // 100 MiB for article HTML
        val cache = Cache(
            directory = File(context.cacheDir, "article_html_cache"),
            maxSize = cacheSize
        )

        return OkHttpClient.Builder()
            .cache(cache)
            .connectTimeout(15, TimeUnit.SECONDS)
            .readTimeout(30, TimeUnit.SECONDS)  // Articles can be large
            .addNetworkInterceptor { chain ->
                val response = chain.proceed(chain.request())

                // Force 7-day cache for article HTML
                val cacheControl = CacheControl.Builder()
                    .maxAge(7, TimeUnit.DAYS)
                    .build()

                response.newBuilder()
                    .header("Cache-Control", cacheControl.toString())
                    .removeHeader("Pragma")
                    .build()
            }
            .addInterceptor { chain ->
                // Add User-Agent to avoid bot blocking
                val request = chain.request().newBuilder()
                    .header("User-Agent", "Mozilla/5.0 (Linux; Android 14) NewsThread/1.0")
                    .build()
                chain.proceed(request)
            }
            .build()
    }
}
```
  </action>
  <verify>
Grep for key patterns:
- "@ArticleHtmlClient" qualifier annotation defined
- "article_html_cache" cache directory
- "maxAge(7, TimeUnit.DAYS)" for 7-day TTL
- "NewsThread/1.0" User-Agent
  </verify>
  <done>ArticleFetchModule provides @ArticleHtmlClient OkHttpClient with 100 MiB cache, 7-day TTL, and proper User-Agent</done>
</task>

<task type="auto">
  <name>Task 2: Create ArticleHtmlFetcher</name>
  <files>app/src/main/java/com/newsthread/app/data/remote/ArticleHtmlFetcher.kt</files>
  <action>
Create ArticleHtmlFetcher that uses the @ArticleHtmlClient OkHttpClient to fetch article HTML with proper error handling.

Key requirements:
- Inject @ArticleHtmlClient qualified OkHttpClient
- Return String? (null on failure)
- Handle 404 (not found), 403/401 (access denied/paywall), timeouts
- Run on Dispatchers.IO via suspend function
- Log errors for debugging

```kotlin
package com.newsthread.app.data.remote

import android.util.Log
import com.newsthread.app.data.remote.di.ArticleHtmlClient
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import okhttp3.OkHttpClient
import okhttp3.Request
import java.io.IOException
import java.net.SocketTimeoutException
import javax.inject.Inject
import javax.inject.Singleton

@Singleton
class ArticleHtmlFetcher @Inject constructor(
    @ArticleHtmlClient private val okHttpClient: OkHttpClient
) {
    /**
     * Fetches HTML content from the given URL.
     *
     * @param url Article URL to fetch
     * @return HTML string on success, null on any failure (404, 403, timeout, etc.)
     */
    suspend fun fetch(url: String): String? = withContext(Dispatchers.IO) {
        try {
            val request = Request.Builder()
                .url(url)
                .build()

            val response = okHttpClient.newCall(request).execute()

            when {
                response.isSuccessful -> {
                    response.body?.string()
                }
                response.code == 404 -> {
                    Log.w(TAG, "Article not found (404): $url")
                    null
                }
                response.code == 403 || response.code == 401 -> {
                    Log.w(TAG, "Access denied (${response.code}, possible paywall): $url")
                    null
                }
                response.code == 429 -> {
                    Log.w(TAG, "Rate limited (429): $url")
                    null
                }
                else -> {
                    Log.e(TAG, "HTTP ${response.code} for: $url")
                    null
                }
            }
        } catch (e: SocketTimeoutException) {
            Log.e(TAG, "Timeout fetching: $url", e)
            null
        } catch (e: IOException) {
            Log.e(TAG, "Network error fetching: $url", e)
            null
        } catch (e: Exception) {
            Log.e(TAG, "Unexpected error fetching: $url", e)
            null
        }
    }

    companion object {
        private const val TAG = "ArticleHtmlFetcher"
    }
}
```
  </action>
  <verify>
Grep for key patterns:
- "@ArticleHtmlClient" injection
- "suspend fun fetch"
- "withContext(Dispatchers.IO)"
- "response.code == 404"
- "SocketTimeoutException"
  </verify>
  <done>ArticleHtmlFetcher fetches HTML via OkHttp, handles 404/403/429/timeout gracefully, returns null on failure</done>
</task>

<task type="auto">
  <name>Task 3: Create NetworkMonitor</name>
  <files>app/src/main/java/com/newsthread/app/util/NetworkMonitor.kt</files>
  <action>
Create NetworkMonitor that uses ConnectivityManager to detect WiFi vs metered connection.

Key requirements:
- Inject ApplicationContext
- Provide isCurrentlyOnWifi(): Boolean for synchronous checks
- Provide isNetworkAvailable(): Boolean for any network
- Check TRANSPORT_WIFI or TRANSPORT_ETHERNET for unmetered
- Check NET_CAPABILITY_VALIDATED for actual internet access
- StateFlow for reactive updates (optional, but useful)

```kotlin
package com.newsthread.app.util

import android.content.Context
import android.net.ConnectivityManager
import android.net.Network
import android.net.NetworkCapabilities
import android.net.NetworkRequest
import dagger.hilt.android.qualifiers.ApplicationContext
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.channels.awaitClose
import kotlinx.coroutines.flow.SharingStarted
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.callbackFlow
import kotlinx.coroutines.flow.stateIn
import javax.inject.Inject
import javax.inject.Singleton

@Singleton
class NetworkMonitor @Inject constructor(
    @ApplicationContext private val context: Context
) {
    private val connectivityManager =
        context.getSystemService(Context.CONNECTIVITY_SERVICE) as ConnectivityManager

    /**
     * StateFlow that emits true when on WiFi/Ethernet with validated internet.
     * Useful for reactive UI updates.
     */
    val isWifiConnected: StateFlow<Boolean> = callbackFlow {
        val callback = object : ConnectivityManager.NetworkCallback() {
            override fun onCapabilitiesChanged(
                network: Network,
                capabilities: NetworkCapabilities
            ) {
                val isWifi = capabilities.hasTransport(NetworkCapabilities.TRANSPORT_WIFI) ||
                             capabilities.hasTransport(NetworkCapabilities.TRANSPORT_ETHERNET)
                val hasInternet = capabilities.hasCapability(NetworkCapabilities.NET_CAPABILITY_VALIDATED)
                trySend(isWifi && hasInternet)
            }

            override fun onLost(network: Network) {
                trySend(false)
            }
        }

        val request = NetworkRequest.Builder()
            .addCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET)
            .build()

        connectivityManager.registerNetworkCallback(request, callback)

        // Emit initial state
        trySend(isCurrentlyOnWifi())

        awaitClose {
            connectivityManager.unregisterNetworkCallback(callback)
        }
    }.stateIn(
        scope = CoroutineScope(Dispatchers.Default),
        started = SharingStarted.WhileSubscribed(5000),
        initialValue = isCurrentlyOnWifi()
    )

    /**
     * Checks if device is currently on WiFi or Ethernet (unmetered) with validated internet.
     *
     * @return true if on WiFi/Ethernet with internet, false otherwise
     */
    fun isCurrentlyOnWifi(): Boolean {
        val network = connectivityManager.activeNetwork ?: return false
        val capabilities = connectivityManager.getNetworkCapabilities(network) ?: return false
        return (capabilities.hasTransport(NetworkCapabilities.TRANSPORT_WIFI) ||
                capabilities.hasTransport(NetworkCapabilities.TRANSPORT_ETHERNET)) &&
               capabilities.hasCapability(NetworkCapabilities.NET_CAPABILITY_VALIDATED)
    }

    /**
     * Checks if any network (WiFi, cellular, etc.) is available with validated internet.
     *
     * @return true if any network with internet is available, false otherwise
     */
    fun isNetworkAvailable(): Boolean {
        val network = connectivityManager.activeNetwork ?: return false
        val capabilities = connectivityManager.getNetworkCapabilities(network) ?: return false
        return capabilities.hasCapability(NetworkCapabilities.NET_CAPABILITY_VALIDATED)
    }
}
```
  </action>
  <verify>
Grep for key patterns:
- "ConnectivityManager"
- "fun isCurrentlyOnWifi(): Boolean"
- "fun isNetworkAvailable(): Boolean"
- "TRANSPORT_WIFI"
- "NET_CAPABILITY_VALIDATED"
  </verify>
  <done>NetworkMonitor detects WiFi/metered state using ConnectivityManager with both sync methods and reactive StateFlow</done>
</task>

</tasks>

<verification>
After completing all tasks:

1. Verify ArticleFetchModule:
   - Grep for "@ArticleHtmlClient" qualifier
   - Grep for "maxAge(7, TimeUnit.DAYS)"
   - Grep for "article_html_cache"

2. Verify ArticleHtmlFetcher:
   - Grep for "@ArticleHtmlClient" injection
   - Grep for "suspend fun fetch"
   - Grep for HTTP error code handling (404, 403, 429)

3. Verify NetworkMonitor:
   - Grep for "fun isCurrentlyOnWifi"
   - Grep for "TRANSPORT_WIFI"
   - Grep for "NET_CAPABILITY_VALIDATED"
</verification>

<success_criteria>
- ArticleFetchModule provides @ArticleHtmlClient OkHttpClient with 100 MiB cache and 7-day TTL
- ArticleHtmlFetcher fetches HTML, returns null on 404/403/429/timeout
- NetworkMonitor provides isCurrentlyOnWifi() and isNetworkAvailable() methods
- All classes use Hilt @Singleton and @Inject patterns
- Network operations run on Dispatchers.IO
</success_criteria>

<output>
After completion, create `.planning/phases/02-text-extraction/02-02-SUMMARY.md`
</output>
