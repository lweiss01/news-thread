---
phase: 02-text-extraction
plan: 04
type: execute
wave: 4
depends_on: ["02-03"]
files_modified:
  - app/src/main/java/com/newsthread/app/presentation/settings/SettingsViewModel.kt
  - app/src/main/java/com/newsthread/app/presentation/settings/SettingsScreen.kt
autonomous: false
user_setup: []

must_haves:
  truths:
    - "User can see current fetch preference in Settings screen"
    - "User can change fetch preference via radio buttons"
    - "Preference changes persist immediately to DataStore"
    - "Settings screen shows ALWAYS, WiFi only, and Never options with descriptions"
  artifacts:
    - path: "app/src/main/java/com/newsthread/app/presentation/settings/SettingsViewModel.kt"
      provides: "ViewModel for settings state"
      contains: "class SettingsViewModel"
    - path: "app/src/main/java/com/newsthread/app/presentation/settings/SettingsScreen.kt"
      provides: "Settings UI with radio buttons"
      contains: "RadioButton"
  key_links:
    - from: "SettingsViewModel"
      to: "UserPreferencesRepository"
      via: "Hilt injection"
      pattern: "userPreferencesRepository"
    - from: "SettingsScreen"
      to: "SettingsViewModel"
      via: "hiltViewModel()"
      pattern: "hiltViewModel"
---

<objective>
Create the Settings UI for article fetch preference: a SettingsViewModel that exposes the preference state, and a SettingsScreen with Material 3 radio buttons for ALWAYS/WIFI_ONLY/NEVER selection.

Purpose: Users need to control when the app fetches full article text to manage their data usage. This completes the user-facing requirement INFRA-02 ("user setting to control article text fetching").

Output:
- SettingsViewModel.kt with preference state and setter
- SettingsScreen.kt with radio button group for fetch preference
</objective>

<execution_context>
@C:\Users\lweis\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\lweis\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-text-extraction/02-CONTEXT.md

# Prior plan context
@.planning/phases/02-text-extraction/02-03-PLAN.md

# Existing files to reference/modify
@app/src/main/java/com/newsthread/app/presentation/settings/SettingsScreen.kt
@app/src/main/java/com/newsthread/app/presentation/feed/FeedScreen.kt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SettingsViewModel</name>
  <files>app/src/main/java/com/newsthread/app/presentation/settings/SettingsViewModel.kt</files>
  <action>
Create SettingsViewModel that exposes the article fetch preference and provides a method to update it.

Key requirements:
- Use @HiltViewModel annotation
- Inject UserPreferencesRepository
- Expose articleFetchPreference as StateFlow<ArticleFetchPreference>
- Provide setArticleFetchPreference() method that launches coroutine
- Use stateIn with SharingStarted.WhileSubscribed(5000) for lifecycle awareness

```kotlin
package com.newsthread.app.presentation.settings

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.newsthread.app.data.repository.UserPreferencesRepository
import com.newsthread.app.domain.model.ArticleFetchPreference
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.SharingStarted
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.stateIn
import kotlinx.coroutines.launch
import javax.inject.Inject

@HiltViewModel
class SettingsViewModel @Inject constructor(
    private val userPreferencesRepository: UserPreferencesRepository
) : ViewModel() {

    /**
     * Current article fetch preference.
     * Updates immediately when user changes the setting.
     */
    val articleFetchPreference: StateFlow<ArticleFetchPreference> =
        userPreferencesRepository.articleFetchPreference
            .stateIn(
                scope = viewModelScope,
                started = SharingStarted.WhileSubscribed(5000),
                initialValue = ArticleFetchPreference.WIFI_ONLY
            )

    /**
     * Updates the article fetch preference.
     * Persists to DataStore immediately.
     *
     * @param preference New preference value
     */
    fun setArticleFetchPreference(preference: ArticleFetchPreference) {
        viewModelScope.launch {
            userPreferencesRepository.setArticleFetchPreference(preference)
        }
    }
}
```
  </action>
  <verify>
Grep for key patterns:
- "@HiltViewModel"
- "class SettingsViewModel"
- "val articleFetchPreference: StateFlow<ArticleFetchPreference>"
- "fun setArticleFetchPreference"
- "userPreferencesRepository"
  </verify>
  <done>SettingsViewModel exposes fetch preference as StateFlow and provides setter method</done>
</task>

<task type="auto">
  <name>Task 2: Update SettingsScreen with fetch preference UI</name>
  <files>app/src/main/java/com/newsthread/app/presentation/settings/SettingsScreen.kt</files>
  <action>
Replace the existing placeholder SettingsScreen with a full implementation that shows radio buttons for article fetch preference.

Key requirements:
- Use hiltViewModel() to get SettingsViewModel
- Use collectAsStateWithLifecycle() for preference state
- Show "Article Text Fetching" section with title and description
- Radio button for each ArticleFetchPreference value
- Each option shows name and description
- Match existing app styling (Material 3)

```kotlin
package com.newsthread.app.presentation.settings

import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.width
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.verticalScroll
import androidx.compose.material3.HorizontalDivider
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.RadioButton
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.runtime.getValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp
import androidx.hilt.navigation.compose.hiltViewModel
import androidx.lifecycle.compose.collectAsStateWithLifecycle
import com.newsthread.app.domain.model.ArticleFetchPreference

@Composable
fun SettingsScreen(
    viewModel: SettingsViewModel = hiltViewModel()
) {
    val fetchPreference by viewModel.articleFetchPreference.collectAsStateWithLifecycle()

    Column(
        modifier = Modifier
            .fillMaxSize()
            .verticalScroll(rememberScrollState())
            .padding(16.dp)
    ) {
        Text(
            text = "Settings",
            style = MaterialTheme.typography.headlineMedium
        )

        Spacer(modifier = Modifier.height(24.dp))

        // Article Text Fetching Section
        ArticleFetchPreferenceSection(
            currentPreference = fetchPreference,
            onPreferenceChanged = viewModel::setArticleFetchPreference
        )

        Spacer(modifier = Modifier.height(16.dp))
        HorizontalDivider()

        // Placeholder for future settings sections
        Spacer(modifier = Modifier.height(16.dp))
        Text(
            text = "More settings coming soon",
            style = MaterialTheme.typography.bodyMedium,
            color = MaterialTheme.colorScheme.onSurfaceVariant
        )
    }
}

@Composable
private fun ArticleFetchPreferenceSection(
    currentPreference: ArticleFetchPreference,
    onPreferenceChanged: (ArticleFetchPreference) -> Unit
) {
    Column {
        Text(
            text = "Article Text Fetching",
            style = MaterialTheme.typography.titleMedium
        )

        Spacer(modifier = Modifier.height(4.dp))

        Text(
            text = "Control when full article text is downloaded for better matching",
            style = MaterialTheme.typography.bodySmall,
            color = MaterialTheme.colorScheme.onSurfaceVariant
        )

        Spacer(modifier = Modifier.height(12.dp))

        ArticleFetchPreference.entries.forEach { preference ->
            FetchPreferenceOption(
                preference = preference,
                isSelected = currentPreference == preference,
                onClick = { onPreferenceChanged(preference) }
            )
        }
    }
}

@Composable
private fun FetchPreferenceOption(
    preference: ArticleFetchPreference,
    isSelected: Boolean,
    onClick: () -> Unit
) {
    Row(
        modifier = Modifier
            .fillMaxWidth()
            .clickable(onClick = onClick)
            .padding(vertical = 12.dp),
        verticalAlignment = Alignment.CenterVertically
    ) {
        RadioButton(
            selected = isSelected,
            onClick = onClick
        )
        Spacer(modifier = Modifier.width(12.dp))
        Column(modifier = Modifier.weight(1f)) {
            Text(
                text = preference.displayName(),
                style = MaterialTheme.typography.bodyLarge
            )
            Text(
                text = preference.description(),
                style = MaterialTheme.typography.bodySmall,
                color = MaterialTheme.colorScheme.onSurfaceVariant
            )
        }
    }
}

/**
 * User-friendly display name for each preference.
 */
private fun ArticleFetchPreference.displayName(): String = when (this) {
    ArticleFetchPreference.ALWAYS -> "Always"
    ArticleFetchPreference.WIFI_ONLY -> "WiFi only"
    ArticleFetchPreference.NEVER -> "Never"
}

/**
 * Description explaining what each preference does.
 */
private fun ArticleFetchPreference.description(): String = when (this) {
    ArticleFetchPreference.ALWAYS -> "Fetch full article text on any network connection"
    ArticleFetchPreference.WIFI_ONLY -> "Only fetch on WiFi to save mobile data (recommended)"
    ArticleFetchPreference.NEVER -> "Never fetch full text, use article summaries only"
}
```
  </action>
  <verify>
Grep for key patterns:
- "hiltViewModel()"
- "collectAsStateWithLifecycle"
- "RadioButton"
- "ArticleFetchPreference.entries"
- "viewModel::setArticleFetchPreference"
  </verify>
  <done>SettingsScreen shows radio buttons for ALWAYS/WIFI_ONLY/NEVER with descriptions</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Settings screen with article fetch preference radio buttons</what-built>
  <how-to-verify>
1. Build and run the app: `gradlew installDebug` or run from Android Studio
2. Navigate to Settings tab (bottom navigation)
3. Verify you see:
   - "Settings" heading
   - "Article Text Fetching" section
   - Three radio button options: Always, WiFi only, Never
   - Each option has a description
4. Tap each option and verify:
   - Radio button selection updates immediately
   - Selection persists after leaving and returning to Settings
   - Selection persists after app restart
5. Verify "WiFi only" is selected by default (first app install)

Expected appearance:
- Clean Material 3 styling
- Radio buttons aligned left
- Option names in body large font
- Descriptions in smaller, muted text
  </how-to-verify>
  <resume-signal>Type "approved" if Settings UI works correctly, or describe any issues</resume-signal>
</task>

</tasks>

<verification>
After completing all tasks:

1. Verify SettingsViewModel:
   - Grep for "@HiltViewModel"
   - Grep for "StateFlow<ArticleFetchPreference>"
   - Grep for "fun setArticleFetchPreference"

2. Verify SettingsScreen:
   - Grep for "hiltViewModel()"
   - Grep for "RadioButton"
   - Grep for "ArticleFetchPreference.entries"

3. Manual verification (checkpoint):
   - Settings screen shows three radio options
   - Selection persists to DataStore
   - Default is WiFi only
</verification>

<success_criteria>
- SettingsViewModel injects UserPreferencesRepository and exposes StateFlow
- SettingsScreen displays radio buttons for all three preferences
- Each option shows name and description
- Selection changes persist immediately
- Default preference is WiFi only
- UI matches Material 3 styling
</success_criteria>

<output>
After completion, create `.planning/phases/02-text-extraction/02-04-SUMMARY.md`
</output>
