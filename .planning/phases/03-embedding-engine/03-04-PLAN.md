---
wave: 2
depends_on: [03-02, 03-03]
files_modified:
  - app/src/main/java/com/example/newsthread/data/repository/EmbeddingRepository.kt (new)
  - app/src/main/java/com/example/newsthread/ui/article/ArticleDetailViewModel.kt
autonomous: false
---

# Plan 03-04: Repository Integration and Lazy Embedding

## Objective

Integrate embedding generation into the repository layer with lazy loading, caching, and error handling as specified in 03-CONTEXT.md.

## Context

From 03-CONTEXT.md:
- **Lazy embedding**: Generate when user opens article detail view
- **Fallback**: Use title + description if text extraction failed
- **Error handling**: Retry once, then silently skip with logging
- **Failure tracking**: Use embedding_status, failure_reason in Room

From Phase 2: TextExtractionRepository provides extracted text

## Tasks

### Task 1: Create Embedding Repository
<task>
<action>
Create `EmbeddingRepository.kt`:

```kotlin
import com.example.newsthread.data.local.dao.CachedEmbeddingDao
import com.example.newsthread.data.local.entities.CachedEmbedding
import com.example.newsthread.data.local.entities.EmbeddingStatus
import com.example.newsthread.embedding.EmbeddingModelManager
import com.example.newsthread.data.preferences.UserPreferencesRepository
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.withContext
import timber.log.Timber
import java.nio.ByteBuffer
import java.nio.ByteOrder
import javax.inject.Inject
import javax.inject.Singleton

@Singleton
class EmbeddingRepository @Inject constructor(
    private val embeddingModelManager: EmbeddingModelManager,
    private val embeddingDao: CachedEmbeddingDao,
    private val userPreferencesRepository: UserPreferencesRepository,
    private val dispatcher: CoroutineDispatcher = Dispatchers.Default
) {
    
    /**
     * Get or generate embedding for an article.
     * Returns null if embedding generation fails after retry.
     */
    suspend fun getOrGenerateEmbedding(
        articleId: String,
        extractedText: String?,
        titleAndDescription: String  // Fallback if extraction failed
    ): FloatArray? = withContext(dispatcher) {
        val modelVersion = userPreferencesRepository.embeddingModelVersion.first()
        
        // Check cache first
        val cachedEmbedding = embeddingDao.getEmbedding(articleId, modelVersion)
        if (cachedEmbedding != null) {
            return@withContext when (cachedEmbedding.embeddingStatus) {
                EmbeddingStatus.SUCCESS -> {
                    Timber.d("Cache hit for article $articleId")
                    byteArrayToFloatArray(cachedEmbedding.embedding)
                }
                EmbeddingStatus.FAILED -> {
                    // Check if retry is allowed (5-minute window)
                    val retryAllowed = System.currentTimeMillis() - cachedEmbedding.lastAttemptAt > 5 * 60 * 1000
                    if (retryAllowed) {
                        Timber.i("Retrying failed embedding for article $articleId")
                        generateAndCacheEmbedding(articleId, extractedText, titleAndDescription, modelVersion, isRetry = true)
                    } else {
                        Timber.d("Skipping article $articleId - recently failed")
                        null
                    }
                }
                EmbeddingStatus.PENDING -> {
                    Timber.w("Article $articleId is pending - race condition?")
                    null
                }
            }
        }
        
        // Generate new embedding
        generateAndCacheEmbedding(articleId, extractedText, titleAndDescription, modelVersion, isRetry = false)
    }
    
    private suspend fun generateAndCacheEmbedding(
        articleId: String,
        extractedText: String?,
        titleAndDescription: String,
        modelVersion: Int,
        isRetry: Boolean
    ): FloatArray? {
        // Mark as pending
        embeddingDao.insert(CachedEmbedding(
            articleId = articleId,
            embedding = ByteArray(0),  // Placeholder
            createdAt = System.currentTimeMillis(),
            modelVersion = modelVersion,
            embeddingStatus = EmbeddingStatus.PENDING,
            failureReason = null,
            lastAttemptAt = System.currentTimeMillis()
        ))
        
        // Choose text: extracted text (primary) or fallback
        val textToEmbed = if (!extractedText.isNullOrBlank()) {
            Timber.d("Using extracted text for embedding (${extractedText.length} chars)")
            extractedText
        } else {
            Timber.d("Using fallback (title + description) for embedding")
            titleAndDescription
        }
        
        // Generate embedding
        val embedding = embeddingModelManager.generateEmbedding(textToEmbed)
        
        if (embedding != null) {
            // Success - cache it
            embeddingDao.insert(CachedEmbedding(
                articleId = articleId,
                embedding = floatArrayToByteArray(embedding),
                createdAt = System.currentTimeMillis(),
                modelVersion = modelVersion,
                embeddingStatus = EmbeddingStatus.SUCCESS,
                failureReason = null,
                lastAttemptAt = System.currentTimeMillis()
            ))
            Timber.i("Embedding generated successfully for article $articleId")
            return embedding
        } else {
            // Failure - log and mark as failed
            val failureReason = if (isRetry) "RETRY_FAILED" else "GENERATION_ERROR"
            embeddingDao.insert(CachedEmbedding(
                articleId = articleId,
                embedding = ByteArray(0),
                createdAt = System.currentTimeMillis(),
                modelVersion = modelVersion,
                embeddingStatus = EmbeddingStatus.FAILED,
                failureReason = failureReason,
                lastAttemptAt = System.currentTimeMillis()
            ))
            Timber.e("Embedding generation failed for article $articleId")
            return null
        }
    }
    
    private fun floatArrayToByteArray(floats: FloatArray): ByteArray {
        val buffer = ByteBuffer.allocate(floats.size * 4).order(ByteOrder.nativeOrder())
        floats.forEach { buffer.putFloat(it) }
        return buffer.array()
    }
    
    private fun byteArrayToFloatArray(bytes: ByteArray): FloatArray {
        val buffer = ByteBuffer.wrap(bytes).order(ByteOrder.nativeOrder())
        return FloatArray(bytes.size / 4) { buffer.getFloat() }
    }
}
```
</action>
<test>
EmbeddingRepository compiles. Can be injected via Hilt.
</test>
</task>

### Task 2: Update ArticleDetailViewModel to Trigger Embedding
<task>
<action>
Modify `ArticleDetailViewModel.kt` to trigger lazy embedding when article is opened:

```kotlin
@HiltViewModel
class ArticleDetailViewModel @Inject constructor(
    private val textExtractionRepository: TextExtractionRepository,
    private val embeddingRepository: EmbeddingRepository,
    // ... existing dependencies
) : ViewModel() {
    
    private val _embeddingState = MutableStateFlow<EmbeddingState>(EmbeddingState.NotStarted)
    val embeddingState: StateFlow<EmbeddingState> = _embeddingState.asStateFlow()
    
    fun onArticleOpened(article: Article) {
        // Existing text extraction logic...
        
        // Trigger lazy embedding (user decision from 03-CONTEXT.md)
        generateEmbeddingIfNeeded(article)
    }
    
    private fun generateEmbeddingIfNeeded(article: Article) {
        viewModelScope.launch {
            _embeddingState.value = EmbeddingState.Loading
            
            // Get extracted text (or null if not available)
            val extractedText = textExtractionRepository
                .getExtractedText(article.url)
                ?.takeIf { it is ExtractionResult.Success }
                ?.let { (it as ExtractionResult.Success).textContent }
            
            // Fallback text
            val fallbackText = "${article.title} ${article.description ?: ""}"
            
            // Generate embedding
            val embedding = embeddingRepository.getOrGenerateEmbedding(
                articleId = article.id,
                extractedText = extractedText,
                titleAndDescription = fallbackText
            )
            
            _embeddingState.value = if (embedding != null) {
                EmbeddingState.Success(embedding)
            } else {
                EmbeddingState.Failed
            }
        }
    }
}

sealed class EmbeddingState {
    object NotStarted : EmbeddingState()
    object Loading : EmbeddingState()
    data class Success(val embedding: FloatArray) : EmbeddingState()
    object Failed : EmbeddingState()
}
```
</action>
<test>
ArticleDetailViewModel compiles. Embedding generation is triggered when article opens.
</test>
</task>

### Task 3: Add Debug Logging for Embedding Status
<task>
<action>
Add Logcat filter tag for easier debugging:

In `EmbeddingRepository.kt` and `EmbeddingModelManager.kt`, use consistent tag:
```kotlin
companion object {
    private const val TAG = "Embedding"
}
Timber.tag(TAG).d("...")
```

This allows filtering with: `adb logcat -s Embedding`
</action>
<test>
Logcat can be filtered with "Embedding" tag to see all embedding-related logs.
</test>
</task>

## Verification Criteria

- [ ] EmbeddingRepository created with lazy loading logic
- [ ] Retry-once logic implemented (5-minute window)
- [ ] Fallback to title + description when extraction fails
- [ ] Failure tracking persisted to Room
- [ ] ArticleDetailViewModel triggers embedding on article open
- [ ] FloatArray â†” ByteArray conversion works
- [ ] App builds successfully

## Must-Haves (Goal-Backward Verification)

**Phase 3 Goal**: Embeddings ready before user taps Compare button

**This plan must deliver**:
- Lazy embedding triggered when article opens
- Embeddings cached in Room for instant retrieval
- Error handling doesn't block user or crash app

## Notes

- This plan completes Phase 3 functionality
- No UI changes in this plan (embedding happens silently)
- Phase 5 will connect embeddings to matching logic
- Manual test: open article, check Logcat for "Embedding generated successfully"
