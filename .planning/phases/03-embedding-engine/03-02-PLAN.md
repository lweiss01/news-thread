---
wave: 1
depends_on: []
files_modified:
  - app/src/main/java/com/example/newsthread/data/local/NewsDatabase.kt
  - app/src/main/java/com/example/newsthread/data/local/dao/CachedEmbeddingDao.kt
  - app/src/main/java/com/example/newsthread/data/local/entities/CachedEmbedding.kt
  - app/src/main/java/com/example/newsthread/data/preferences/UserPreferencesKeys.kt
autonomous: false
---

# Plan 03-02: Database Schema and DataStore Updates

## Objective

Update Room database schema to track embedding model version, status, and failures. Add DataStore preference for current model version.

## Context

From 03-CONTEXT.md:
- Add `model_version`, `embedding_status`, `failure_reason`, `last_attempt_at` to cached_embeddings table
- Store `EMBEDDING_MODEL_VERSION = 1` in DataStore

From Phase 1: cached_embeddings table already exists with basic structure.

## Tasks

### Task 1: Update CachedEmbedding Entity
<task>
<action>
Modify `CachedEmbedding.kt` to add new columns:

```kotlin
@Entity(tableName = "cached_embeddings")
data class CachedEmbedding(
    @PrimaryKey
    val articleId: String,
    val embedding: ByteArray,  // Existing: FloatArray stored as BLOB
    val createdAt: Long,      // Existing
    val modelVersion: Int,    // NEW: tracks which model generated this
    val embeddingStatus: EmbeddingStatus,  // NEW: SUCCESS, FAILED, PENDING
    val failureReason: String?,  // NEW: "OOM", "MODEL_ERROR", "TEXT_TOO_LONG", null if SUCCESS
    val lastAttemptAt: Long   // NEW: timestamp of last embedding attempt
) {
    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (javaClass != other?.javaClass) return false
        other as CachedEmbedding
        return articleId == other.articleId
    }

    override fun hashCode(): Int {
        return articleId.hashCode()
    }
}

enum class EmbeddingStatus {
    SUCCESS,
    FAILED,
    PENDING
}
```
</action>
<test>
Code compiles. Entity schema updated.
</test>
</task>

### Task 2: Create Room Database Migration (v3 → v4)
<task>
<action>
Add migration in `NewsDatabase.kt`:

```kotlin
val MIGRATION_3_4 = object : Migration(3, 4) {
    override fun migrate(database: SupportSQLiteDatabase) {
        // Add new columns to cached_embeddings table
        database.execSQL("""
            ALTER TABLE cached_embeddings 
            ADD COLUMN model_version INTEGER NOT NULL DEFAULT 1
        """)
        database.execSQL("""
            ALTER TABLE cached_embeddings 
            ADD COLUMN embedding_status TEXT NOT NULL DEFAULT 'SUCCESS'
        """)
        database.execSQL("""
            ALTER TABLE cached_embeddings 
            ADD COLUMN failure_reason TEXT
        """)
        database.execSQL("""
            ALTER TABLE cached_embeddings 
            ADD COLUMN last_attempt_at INTEGER NOT NULL DEFAULT 0
        """)
    }
}
```

Update `NewsDatabase` annotation:
```kotlin
@Database(
    entities = [Article::class, CachedEmbedding::class, /* ... */],
    version = 4,  // Increment from 3 to 4
    exportSchema = true
)
```

Add migration to database builder:
```kotlin
Room.databaseBuilder(...)
    .addMigrations(MIGRATION_2_3, MIGRATION_3_4)  // Add new migration
    .build()
```
</action>
<test>
App builds. Migration script is syntactically correct.
Database version incremented to 4.
</test>
</task>

### Task 3: Update CachedEmbeddingDao Queries
<task>
<action>
Update `CachedEmbeddingDao.kt` to handle new columns:

```kotlin
@Dao
interface CachedEmbeddingDao {
    @Query("SELECT * FROM cached_embeddings WHERE articleId = :articleId AND model_version = :modelVersion")
    suspend fun getEmbedding(articleId: String, modelVersion: Int): CachedEmbedding?
    
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insert(embedding: CachedEmbedding)
    
    @Query("DELETE FROM cached_embeddings WHERE createdAt < :expiryTimestamp")
    suspend fun deleteExpired(expiryTimestamp: Long)
    
    @Query("SELECT * FROM cached_embeddings WHERE embedding_status = 'FAILED'")
    suspend fun getFailedEmbeddings(): List<CachedEmbedding>
    
    @Query("UPDATE cached_embeddings SET embedding_status = 'PENDING', last_attempt_at = :timestamp WHERE articleId = :articleId")
    suspend fun markForRetry(articleId: String, timestamp: Long)
}
```
</action>
<test>
DAO compiles without errors. Queries are syntactically correct.
</test>
</task>

### Task 4: Add Model Version to DataStore
<task>
<action>
Add to `UserPreferencesKeys.kt`:

```kotlin
object UserPreferencesKeys {
    // Existing keys...
    val ARTICLE_FETCH_PREFERENCE = stringPreferencesKey("article_fetch_preference")
    
    // NEW: Embedding model version
    val EMBEDDING_MODEL_VERSION = intPreferencesKey("embedding_model_version")
}
```

Update `UserPreferencesRepository` to expose model version:

```kotlin
val embeddingModelVersion: Flow<Int> = dataStore.data
    .map { preferences ->
        preferences[UserPreferencesKeys.EMBEDDING_MODEL_VERSION] ?: 1  // Default v1
    }

suspend fun setEmbeddingModelVersion(version: Int) {
    dataStore.edit { preferences ->
        preferences[UserPreferencesKeys.EMBEDDING_MODEL_VERSION] = version
    }
}
```
</action>
<test>
UserPreferences repository compiles.
Model version can be read/written to DataStore.
</test>
</task>

### Task 5: Add Type Converters for EmbeddingStatus Enum
<task>
<action>
Add type converter to `NewsDatabase.kt`:

```kotlin
class Converters {
    // Existing converters...
    
    @TypeConverter
    fun fromEmbeddingStatus(status: EmbeddingStatus): String {
        return status.name
    }
    
    @TypeConverter
    fun toEmbeddingStatus(status: String): EmbeddingStatus {
        return EmbeddingStatus.valueOf(status)
    }
}
```

Ensure converter is registered in @Database annotation:
```kotlin
@Database(...)
@TypeConverters(Converters::class)
abstract class NewsDatabase : RoomDatabase { ... }
```
</action>
<test>
Type converters compile and are registered.
</test>
</task>

## Verification Criteria

- [ ] CachedEmbedding entity updated with 4 new columns
- [ ] EmbeddingStatus enum created
- [ ] Database migration 3 → 4 created
- [ ] Database version incremented to 4
- [ ] CachedEmbeddingDao queries updated
- [ ] EMBEDDING_MODEL_VERSION added to DataStore
- [ ] Type converters for EmbeddingStatus enum added
- [ ] App builds successfully

## Must-Haves (Goal-Backward Verification)

**Phase 3 Goal**: Store embeddings with version tracking and failure handling

**This plan must deliver**:
- Database schema supports model versioning
- Failure tracking infrastructure in place
- DataStore tracks current model version

## Notes

- Migration must handle existing embeddings (default to version 1, status SUCCESS)
- No data loss during migration
- Failure tracking enables retry logic (Plan 03-04)
